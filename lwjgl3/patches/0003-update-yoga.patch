diff --git a/modules/lwjgl/yoga/src/main/c/BitUtils.h b/modules/lwjgl/yoga/src/main/c/BitUtils.h
new file mode 100644
index 000000000..2161effc7
--- /dev/null
+++ b/modules/lwjgl/yoga/src/main/c/BitUtils.h
@@ -0,0 +1,67 @@
+/*
+ * Copyright (c) Facebook, Inc. and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+#pragma once
+
+#include <cstdio>
+#include <cstdint>
+#include "YGEnums.h"
+
+namespace facebook {
+namespace yoga {
+
+namespace detail {
+
+constexpr size_t log2ceilFn(size_t n) {
+  return n < 1 ? 0 : (1 + log2ceilFn(n / 2));
+}
+
+constexpr int mask(size_t bitWidth, size_t index) {
+  return ((1 << bitWidth) - 1) << index;
+}
+
+// The number of bits necessary to represent enums defined with YG_ENUM_SEQ_DECL
+template <typename Enum>
+constexpr size_t bitWidthFn() {
+  static_assert(
+      enums::count<Enum>() > 0, "Enums must have at least one entries");
+  return log2ceilFn(enums::count<Enum>() - 1);
+}
+
+template <typename Enum>
+constexpr Enum getEnumData(int flags, size_t index) {
+  return static_cast<Enum>((flags & mask(bitWidthFn<Enum>(), index)) >> index);
+}
+
+template <typename Enum>
+void setEnumData(uint32_t& flags, size_t index, int newValue) {
+  flags = (flags & ~mask(bitWidthFn<Enum>(), index)) |
+      ((newValue << index) & (mask(bitWidthFn<Enum>(), index)));
+}
+
+template <typename Enum>
+void setEnumData(uint8_t& flags, size_t index, int newValue) {
+  flags = (flags & ~static_cast<uint8_t>(mask(bitWidthFn<Enum>(), index))) |
+      ((newValue << index) &
+       (static_cast<uint8_t>(mask(bitWidthFn<Enum>(), index))));
+}
+
+constexpr bool getBooleanData(int flags, size_t index) {
+  return (flags >> index) & 1;
+}
+
+inline void setBooleanData(uint8_t& flags, size_t index, bool value) {
+  if (value) {
+    flags |= 1 << index;
+  } else {
+    flags &= ~(1 << index);
+  }
+}
+
+} // namespace detail
+} // namespace yoga
+} // namespace facebook
diff --git a/modules/lwjgl/yoga/src/main/c/CompactValue.h b/modules/lwjgl/yoga/src/main/c/CompactValue.h
index 3cc36a488..f398668e2 100644
--- a/modules/lwjgl/yoga/src/main/c/CompactValue.h
+++ b/modules/lwjgl/yoga/src/main/c/CompactValue.h
@@ -1,13 +1,14 @@
-/**
+/*
  * Copyright (c) Facebook, Inc. and its affiliates.
  *
- * This source code is licensed under the MIT license found in the LICENSE
- * file in the root directory of this source tree.
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
  */
+
 #pragma once
 
 #include "YGValue.h"
-
+#include "YGMacros.h"
 #include <cmath>
 #include <cstdint>
 #include <limits>
@@ -39,7 +40,7 @@ namespace detail {
 //            0x40000000         0x7f7fffff
 // - Zero is supported, negative zero is not
 // - values outside of the representable range are clamped
-class CompactValue {
+class YOGA_EXPORT CompactValue {
   friend constexpr bool operator==(CompactValue, CompactValue) noexcept;
 
 public:
@@ -124,8 +125,8 @@ public:
     data.repr &= ~PERCENT_BIT;
     data.repr += BIAS;
 
-    return YGValue{data.value,
-                   payload_.repr & 0x40000000 ? YGUnitPercent : YGUnitPoint};
+    return YGValue{
+        data.value, payload_.repr & 0x40000000 ? YGUnitPercent : YGUnitPoint};
   }
 
   bool isUndefined() const noexcept {
@@ -134,9 +135,7 @@ public:
         payload_.repr != ZERO_BITS_PERCENT && std::isnan(payload_.value));
   }
 
-  bool isAuto() const noexcept {
-    return payload_.repr == AUTO_BITS;
-  }
+  bool isAuto() const noexcept { return payload_.repr == AUTO_BITS; }
 
 private:
   union Payload {
@@ -160,9 +159,7 @@ private:
 
   Payload payload_;
 
-  VISIBLE_FOR_TESTING uint32_t repr() {
-    return payload_.repr;
-  }
+  VISIBLE_FOR_TESTING uint32_t repr() { return payload_.repr; }
 };
 
 template <>
diff --git a/modules/lwjgl/yoga/src/main/c/Utils.cpp b/modules/lwjgl/yoga/src/main/c/Utils.cpp
index 38b686c58..eaa74b062 100644
--- a/modules/lwjgl/yoga/src/main/c/Utils.cpp
+++ b/modules/lwjgl/yoga/src/main/c/Utils.cpp
@@ -1,10 +1,12 @@
-/**
+/*
  * Copyright (c) Facebook, Inc. and its affiliates.
  *
- * This source code is licensed under the MIT license found in the LICENSE
- * file in the root directory of this source tree.
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
  */
+
 #include "Utils.h"
+#include <stdexcept>
 
 using namespace facebook;
 
@@ -51,6 +53,13 @@ bool YGFloatsEqual(const float a, const float b) {
   return yoga::isUndefined(a) && yoga::isUndefined(b);
 }
 
+bool YGDoubleEqual(const double a, const double b) {
+  if (!yoga::isUndefined(a) && !yoga::isUndefined(b)) {
+    return fabs(a - b) < 0.0001;
+  }
+  return yoga::isUndefined(a) && yoga::isUndefined(b);
+}
+
 float YGFloatSanitize(const float val) {
   return yoga::isUndefined(val) ? 0 : val;
 }
@@ -64,3 +73,7 @@ YGFloatOptional YGFloatOptionalMax(YGFloatOptional op1, YGFloatOptional op2) {
   }
   return op1.isUndefined() ? op2 : op1;
 }
+
+void throwLogicalErrorWithMessage(const char* message) {
+  throw std::logic_error(message);
+}
diff --git a/modules/lwjgl/yoga/src/main/c/Utils.h b/modules/lwjgl/yoga/src/main/c/Utils.h
index 900ccb1be..57e1d45d9 100644
--- a/modules/lwjgl/yoga/src/main/c/Utils.h
+++ b/modules/lwjgl/yoga/src/main/c/Utils.h
@@ -1,9 +1,10 @@
-/**
+/*
  * Copyright (c) Facebook, Inc. and its affiliates.
  *
- * This source code is licensed under the MIT license found in the LICENSE
- * file in the root directory of this source tree.
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
  */
+
 #pragma once
 #include "YGNode.h"
 #include "Yoga-internal.h"
@@ -30,7 +31,7 @@
 //
 // - endOfLineIndex: Its the end index of the last flex item which was examined
 //   and it may or may not be part of the current line(as it may be absolutely
-//   positioned or inculding it may have caused to overshoot availableInnerDim)
+//   positioned or including it may have caused to overshoot availableInnerDim)
 //
 // - relativeChildren: Maintain a vector of the child nodes that can shrink
 //   and/or grow.
@@ -63,6 +64,8 @@ inline bool YGValueEqual(
 // difference between two floats is less than 0.0001f or both are undefined.
 bool YGFloatsEqual(const float a, const float b);
 
+bool YGDoubleEqual(const double a, const double b);
+
 float YGFloatMax(const float a, const float b);
 
 YGFloatOptional YGFloatOptionalMax(
@@ -71,8 +74,8 @@ YGFloatOptional YGFloatOptionalMax(
 
 float YGFloatMin(const float a, const float b);
 
-// This custom float comparision function compares the array of float with
-// YGFloatsEqual, as the default float comparision operator will not work(Look
+// This custom float comparison function compares the array of float with
+// YGFloatsEqual, as the default float comparison operator will not work(Look
 // at the comments of YGFloatsEqual function).
 template <std::size_t size>
 bool YGFloatArrayEqual(
@@ -140,3 +143,5 @@ inline YGFloatOptional YGResolveValueMargin(
     const float ownerSize) {
   return value.isAuto() ? YGFloatOptional{0} : YGResolveValue(value, ownerSize);
 }
+
+void throwLogicalErrorWithMessage(const char* message);
diff --git a/modules/lwjgl/yoga/src/main/c/YGConfig.cpp b/modules/lwjgl/yoga/src/main/c/YGConfig.cpp
index 773ad24ab..fb72e80cf 100644
--- a/modules/lwjgl/yoga/src/main/c/YGConfig.cpp
+++ b/modules/lwjgl/yoga/src/main/c/YGConfig.cpp
@@ -1,9 +1,10 @@
-/**
+/*
  * Copyright (c) Facebook, Inc. and its affiliates.
  *
- * This source code is licensed under the MIT license found in the LICENSE
- * file in the root directory of this source tree.
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
  */
+
 #include "YGConfig.h"
 
 YGConfig::YGConfig(YGLogger logger) : cloneNodeCallback_{nullptr} {
diff --git a/modules/lwjgl/yoga/src/main/c/YGConfig.h b/modules/lwjgl/yoga/src/main/c/YGConfig.h
index e0f29c5f2..e87d67586 100644
--- a/modules/lwjgl/yoga/src/main/c/YGConfig.h
+++ b/modules/lwjgl/yoga/src/main/c/YGConfig.h
@@ -1,15 +1,15 @@
-/**
+/*
  * Copyright (c) Facebook, Inc. and its affiliates.
  *
- * This source code is licensed under the MIT license found in the LICENSE
- * file in the root directory of this source tree.
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
  */
+
 #pragma once
-#include "YGMarker.h"
 #include "Yoga-internal.h"
 #include "Yoga.h"
 
-struct YGConfig {
+struct YOGA_EXPORT YGConfig {
   using LogWithContextFn = int (*)(
       YGConfigRef config,
       YGNodeRef node,
@@ -44,7 +44,6 @@ public:
   std::array<bool, facebook::yoga::enums::count<YGExperimentalFeature>()>
       experimentalFeatures = {};
   void* context = nullptr;
-  YGMarkerCallbacks markerCallbacks = {nullptr, nullptr};
 
   YGConfig(YGLogger logger);
   void log(YGConfig*, YGNode*, YGLogLevel, void*, const char*, va_list);
@@ -56,9 +55,7 @@ public:
     logger_.withContext = logger;
     loggerUsesContext_ = true;
   }
-  void setLogger(std::nullptr_t) {
-    setLogger(YGLogger{nullptr});
-  }
+  void setLogger(std::nullptr_t) { setLogger(YGLogger{nullptr}); }
 
   YGNodeRef cloneNode(
       YGNodeRef node,
diff --git a/modules/lwjgl/yoga/src/main/c/YGEnums.cpp b/modules/lwjgl/yoga/src/main/c/YGEnums.cpp
index ff4b13076..c01d3d94b 100644
--- a/modules/lwjgl/yoga/src/main/c/YGEnums.cpp
+++ b/modules/lwjgl/yoga/src/main/c/YGEnums.cpp
@@ -1,9 +1,10 @@
-/**
+/*
  * Copyright (c) Facebook, Inc. and its affiliates.
  *
- * This source code is licensed under the MIT license found in the LICENSE
- * file in the root directory of this source tree.
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
  */
+
 #include "YGEnums.h"
 
 const char* YGAlignToString(const YGAlign value) {
@@ -178,6 +179,8 @@ const char* YGOverflowToString(const YGOverflow value) {
 
 const char* YGPositionTypeToString(const YGPositionType value) {
   switch (value) {
+    case YGPositionTypeStatic:
+      return "static";
     case YGPositionTypeRelative:
       return "relative";
     case YGPositionTypeAbsolute:
diff --git a/modules/lwjgl/yoga/src/main/c/YGEnums.h b/modules/lwjgl/yoga/src/main/c/YGEnums.h
index f06b0e045..3dc458dcb 100644
--- a/modules/lwjgl/yoga/src/main/c/YGEnums.h
+++ b/modules/lwjgl/yoga/src/main/c/YGEnums.h
@@ -1,9 +1,10 @@
-/**
+/*
  * Copyright (c) Facebook, Inc. and its affiliates.
  *
- * This source code is licensed under the MIT license found in the LICENSE
- * file in the root directory of this source tree.
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
  */
+
 #pragma once
 
 #include "YGMacros.h"
@@ -127,7 +128,11 @@ YG_ENUM_SEQ_DECL(
     YGOverflowHidden,
     YGOverflowScroll)
 
-YG_ENUM_SEQ_DECL(YGPositionType, YGPositionTypeRelative, YGPositionTypeAbsolute)
+YG_ENUM_SEQ_DECL(
+    YGPositionType,
+    YGPositionTypeStatic,
+    YGPositionTypeRelative,
+    YGPositionTypeAbsolute)
 
 YG_ENUM_DECL(
     YGPrintOptions,
diff --git a/modules/lwjgl/yoga/src/main/c/YGFloatOptional.h b/modules/lwjgl/yoga/src/main/c/YGFloatOptional.h
index 02d4c856d..e4cf0284b 100644
--- a/modules/lwjgl/yoga/src/main/c/YGFloatOptional.h
+++ b/modules/lwjgl/yoga/src/main/c/YGFloatOptional.h
@@ -1,9 +1,10 @@
-/**
+/*
  * Copyright (c) Facebook, Inc. and its affiliates.
  *
- * This source code is licensed under the MIT license found in the LICENSE
- * file in the root directory of this source tree.
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
  */
+
 #pragma once
 
 #include <cmath>
@@ -19,40 +20,51 @@ public:
   constexpr YGFloatOptional() = default;
 
   // returns the wrapped value, or a value x with YGIsUndefined(x) == true
-  constexpr float unwrap() const {
-    return value_;
-  }
-
-  bool isUndefined() const {
-    return std::isnan(value_);
-  }
-
-  YGFloatOptional operator+(YGFloatOptional op) const {
-    return YGFloatOptional{value_ + op.value_};
-  }
-  bool operator>(YGFloatOptional op) const {
-    return value_ > op.value_;
-  }
-  bool operator<(YGFloatOptional op) const {
-    return value_ < op.value_;
-  }
-  bool operator>=(YGFloatOptional op) const {
-    return *this > op || *this == op;
-  }
-  bool operator<=(YGFloatOptional op) const {
-    return *this < op || *this == op;
-  }
-  bool operator==(YGFloatOptional op) const {
-    return value_ == op.value_ || (isUndefined() && op.isUndefined());
-  }
-  bool operator!=(YGFloatOptional op) const {
-    return !(*this == op);
-  }
-
-  bool operator==(float val) const {
-    return value_ == val || (isUndefined() && yoga::isUndefined(val));
-  }
-  bool operator!=(float val) const {
-    return !(*this == val);
-  }
+  constexpr float unwrap() const { return value_; }
+
+  bool isUndefined() const { return std::isnan(value_); }
 };
+
+// operators take YGFloatOptional by value, as it is a 32bit value
+
+inline bool operator==(YGFloatOptional lhs, YGFloatOptional rhs) {
+  return lhs.unwrap() == rhs.unwrap() ||
+      (lhs.isUndefined() && rhs.isUndefined());
+}
+inline bool operator!=(YGFloatOptional lhs, YGFloatOptional rhs) {
+  return !(lhs == rhs);
+}
+
+inline bool operator==(YGFloatOptional lhs, float rhs) {
+  return lhs == YGFloatOptional{rhs};
+}
+inline bool operator!=(YGFloatOptional lhs, float rhs) {
+  return !(lhs == rhs);
+}
+
+inline bool operator==(float lhs, YGFloatOptional rhs) {
+  return rhs == lhs;
+}
+inline bool operator!=(float lhs, YGFloatOptional rhs) {
+  return !(lhs == rhs);
+}
+
+inline YGFloatOptional operator+(YGFloatOptional lhs, YGFloatOptional rhs) {
+  return YGFloatOptional{lhs.unwrap() + rhs.unwrap()};
+}
+
+inline bool operator>(YGFloatOptional lhs, YGFloatOptional rhs) {
+  return lhs.unwrap() > rhs.unwrap();
+}
+
+inline bool operator<(YGFloatOptional lhs, YGFloatOptional rhs) {
+  return lhs.unwrap() < rhs.unwrap();
+}
+
+inline bool operator>=(YGFloatOptional lhs, YGFloatOptional rhs) {
+  return lhs > rhs || lhs == rhs;
+}
+
+inline bool operator<=(YGFloatOptional lhs, YGFloatOptional rhs) {
+  return lhs < rhs || lhs == rhs;
+}
diff --git a/modules/lwjgl/yoga/src/main/c/YGLayout.cpp b/modules/lwjgl/yoga/src/main/c/YGLayout.cpp
index 6f55d862c..e43213cdc 100644
--- a/modules/lwjgl/yoga/src/main/c/YGLayout.cpp
+++ b/modules/lwjgl/yoga/src/main/c/YGLayout.cpp
@@ -1,9 +1,10 @@
-/**
+/*
  * Copyright (c) Facebook, Inc. and its affiliates.
  *
- * This source code is licensed under the MIT license found in the LICENSE
- * file in the root directory of this source tree.
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
  */
+
 #include "YGLayout.h"
 #include "Utils.h"
 
@@ -15,7 +16,8 @@ bool YGLayout::operator==(YGLayout layout) const {
       YGFloatArrayEqual(margin, layout.margin) &&
       YGFloatArrayEqual(border, layout.border) &&
       YGFloatArrayEqual(padding, layout.padding) &&
-      direction == layout.direction && hadOverflow == layout.hadOverflow &&
+      direction() == layout.direction() &&
+      hadOverflow() == layout.hadOverflow() &&
       lastOwnerDirection == layout.lastOwnerDirection &&
       nextCachedMeasurementsIndex == layout.nextCachedMeasurementsIndex &&
       cachedLayout == layout.cachedLayout &&
diff --git a/modules/lwjgl/yoga/src/main/c/YGLayout.h b/modules/lwjgl/yoga/src/main/c/YGLayout.h
index 4daa28edb..b7604d8e2 100644
--- a/modules/lwjgl/yoga/src/main/c/YGLayout.h
+++ b/modules/lwjgl/yoga/src/main/c/YGLayout.h
@@ -1,50 +1,87 @@
-/**
+/*
  * Copyright (c) Facebook, Inc. and its affiliates.
  *
- * This source code is licensed under the MIT license found in the LICENSE
- * file in the root directory of this source tree.
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
  */
+
 #pragma once
+#include "BitUtils.h"
 #include "YGFloatOptional.h"
 #include "Yoga-internal.h"
 
-constexpr std::array<float, 2> kYGDefaultDimensionValues = {
-    {YGUndefined, YGUndefined}};
+using namespace facebook::yoga;
 
 struct YGLayout {
   std::array<float, 4> position = {};
-  std::array<float, 2> dimensions = kYGDefaultDimensionValues;
-  std::array<float, 6> margin = {};
-  std::array<float, 6> border = {};
-  std::array<float, 6> padding = {};
-  YGDirection direction : 2;
-  bool didUseLegacyFlag : 1;
-  bool doesLegacyStretchFlagAffectsLayout : 1;
-  bool hadOverflow : 1;
+  std::array<float, 2> dimensions = {{YGUndefined, YGUndefined}};
+  std::array<float, 4> margin = {};
+  std::array<float, 4> border = {};
+  std::array<float, 4> padding = {};
+
+private:
+  static constexpr size_t directionOffset = 0;
+  static constexpr size_t didUseLegacyFlagOffset =
+      directionOffset + facebook::yoga::detail::bitWidthFn<YGDirection>();
+  static constexpr size_t doesLegacyStretchFlagAffectsLayoutOffset =
+      didUseLegacyFlagOffset + 1;
+  static constexpr size_t hadOverflowOffset =
+      doesLegacyStretchFlagAffectsLayoutOffset + 1;
+  uint8_t flags = 0;
 
+public:
   uint32_t computedFlexBasisGeneration = 0;
   YGFloatOptional computedFlexBasis = {};
 
   // Instead of recomputing the entire layout every single time, we cache some
   // information to break early when nothing changed
   uint32_t generationCount = 0;
-  YGDirection lastOwnerDirection = (YGDirection) -1;
+  YGDirection lastOwnerDirection = YGDirectionInherit;
 
   uint32_t nextCachedMeasurementsIndex = 0;
   std::array<YGCachedMeasurement, YG_MAX_CACHED_RESULT_COUNT>
       cachedMeasurements = {};
-  std::array<float, 2> measuredDimensions = kYGDefaultDimensionValues;
+  std::array<float, 2> measuredDimensions = {{YGUndefined, YGUndefined}};
 
   YGCachedMeasurement cachedLayout = YGCachedMeasurement();
 
-  YGLayout()
-      : direction(YGDirectionInherit),
-        didUseLegacyFlag(false),
-        doesLegacyStretchFlagAffectsLayout(false),
-        hadOverflow(false) {}
+  YGDirection direction() const {
+    return facebook::yoga::detail::getEnumData<YGDirection>(
+        flags, directionOffset);
+  }
 
-  bool operator==(YGLayout layout) const;
-  bool operator!=(YGLayout layout) const {
-    return !(*this == layout);
+  void setDirection(YGDirection direction) {
+    facebook::yoga::detail::setEnumData<YGDirection>(
+        flags, directionOffset, direction);
   }
+
+  bool didUseLegacyFlag() const {
+    return facebook::yoga::detail::getBooleanData(
+        flags, didUseLegacyFlagOffset);
+  }
+
+  void setDidUseLegacyFlag(bool val) {
+    facebook::yoga::detail::setBooleanData(flags, didUseLegacyFlagOffset, val);
+  }
+
+  bool doesLegacyStretchFlagAffectsLayout() const {
+    return facebook::yoga::detail::getBooleanData(
+        flags, doesLegacyStretchFlagAffectsLayoutOffset);
+  }
+
+  void setDoesLegacyStretchFlagAffectsLayout(bool val) {
+    facebook::yoga::detail::setBooleanData(
+        flags, doesLegacyStretchFlagAffectsLayoutOffset, val);
+  }
+
+  bool hadOverflow() const {
+    return facebook::yoga::detail::getBooleanData(flags, hadOverflowOffset);
+  }
+  void setHadOverflow(bool hadOverflow) {
+    facebook::yoga::detail::setBooleanData(
+        flags, hadOverflowOffset, hadOverflow);
+  }
+
+  bool operator==(YGLayout layout) const;
+  bool operator!=(YGLayout layout) const { return !(*this == layout); }
 };
diff --git a/modules/lwjgl/yoga/src/main/c/YGMacros.h b/modules/lwjgl/yoga/src/main/c/YGMacros.h
index b11606b6b..c6917f1b1 100644
--- a/modules/lwjgl/yoga/src/main/c/YGMacros.h
+++ b/modules/lwjgl/yoga/src/main/c/YGMacros.h
@@ -1,9 +1,10 @@
-/**
+/*
  * Copyright (c) Facebook, Inc. and its affiliates.
  *
- * This source code is licensed under the MIT license found in the LICENSE
- * file in the root directory of this source tree.
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
  */
+
 #pragma once
 
 #ifdef __cplusplus
@@ -20,16 +21,33 @@
 #define WIN_EXPORT
 #endif
 
+#ifndef YOGA_EXPORT
+#ifdef _MSC_VER
+#define YOGA_EXPORT
+#else
+#define YOGA_EXPORT __attribute__((visibility("default")))
+#endif
+#endif
+
 #ifdef NS_ENUM
 // Cannot use NSInteger as NSInteger has a different size than int (which is the
 // default type of a enum). Therefor when linking the Yoga C library into obj-c
 // the header is a missmatch for the Yoga ABI.
 #define YG_ENUM_BEGIN(name) NS_ENUM(int, name)
 #define YG_ENUM_END(name)
-#elif defined(LWJGL_WINDOWS)
-#define YG_ENUM_BEGIN(name) enum name : unsigned
-#define YG_ENUM_END(name) name
 #else
 #define YG_ENUM_BEGIN(name) enum name
 #define YG_ENUM_END(name) name
 #endif
+
+#ifdef __GNUC__
+#define YG_DEPRECATED __attribute__((deprecated))
+#elif defined(_MSC_VER)
+#define YG_DEPRECATED __declspec(deprecated)
+#elif __cplusplus >= 201402L
+#if defined(__has_cpp_attribute)
+#if __has_cpp_attribute(deprecated)
+#define YG_DEPRECATED [[deprecated]]
+#endif
+#endif
+#endif
diff --git a/modules/lwjgl/yoga/src/main/c/YGMarker.cpp b/modules/lwjgl/yoga/src/main/c/YGMarker.cpp
deleted file mode 100644
index 21a8d1f6c..000000000
--- a/modules/lwjgl/yoga/src/main/c/YGMarker.cpp
+++ /dev/null
@@ -1,14 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the LICENSE
- * file in the root directory of this source tree.
- */
-#include "YGMarker.h"
-#include "YGConfig.h"
-
-void YGConfigSetMarkerCallbacks(
-    YGConfigRef config,
-    YGMarkerCallbacks markerCallbacks) {
-  config->markerCallbacks = markerCallbacks;
-}
diff --git a/modules/lwjgl/yoga/src/main/c/YGMarker.h b/modules/lwjgl/yoga/src/main/c/YGMarker.h
deleted file mode 100644
index 25362ff52..000000000
--- a/modules/lwjgl/yoga/src/main/c/YGMarker.h
+++ /dev/null
@@ -1,94 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the LICENSE
- * file in the root directory of this source tree.
- */
-#pragma once
-
-#include "YGMacros.h"
-
-YG_EXTERN_C_BEGIN
-
-typedef struct YGNode* YGNodeRef;
-typedef struct YGConfig* YGConfigRef;
-
-typedef YG_ENUM_BEGIN(YGMarker){
-    YGMarkerLayout,
-    YGMarkerMeasure,
-    YGMarkerBaselineFn,
-} YG_ENUM_END(YGMarker);
-
-typedef struct {
-  int layouts;
-  int measures;
-  int maxMeasureCache;
-  int cachedLayouts;
-  int cachedMeasures;
-} YGMarkerLayoutData;
-
-typedef struct {
-  bool _unused;
-} YGMarkerNoData;
-
-typedef union {
-  YGMarkerLayoutData* layout;
-  YGMarkerNoData* noData;
-} YGMarkerData;
-
-typedef struct {
-  // accepts marker type, a node ref, and marker data (depends on marker type)
-  // can return a handle or id that Yoga will pass to endMarker
-  void* (*startMarker)(YGMarker, YGNodeRef, YGMarkerData);
-  // accepts marker type, a node ref, marker data, and marker id as returned by
-  // startMarker
-  void (*endMarker)(YGMarker, YGNodeRef, YGMarkerData, void* id);
-} YGMarkerCallbacks;
-
-void YGConfigSetMarkerCallbacks(YGConfigRef, YGMarkerCallbacks);
-
-YG_EXTERN_C_END
-
-#ifdef __cplusplus
-
-namespace facebook {
-namespace yoga {
-namespace marker {
-namespace detail {
-
-template <YGMarker M>
-struct MarkerData;
-
-template <>
-struct MarkerData<YGMarkerLayout> {
-  using type = YGMarkerLayoutData;
-  static type*& get(YGMarkerData& d) {
-    return d.layout;
-  }
-};
-
-struct NoMarkerData {
-  using type = YGMarkerNoData;
-  static type*& get(YGMarkerData& d) {
-    return d.noData;
-  }
-};
-
-template <>
-struct MarkerData<YGMarkerMeasure> : NoMarkerData {};
-
-template <>
-struct MarkerData<YGMarkerBaselineFn> : NoMarkerData {};
-
-} // namespace detail
-
-template <YGMarker M>
-typename detail::MarkerData<M>::type* data(YGMarkerData d) {
-  return detail::MarkerData<M>::get(d);
-}
-
-} // namespace marker
-} // namespace yoga
-} // namespace facebook
-
-#endif // __cplusplus
diff --git a/modules/lwjgl/yoga/src/main/c/YGNode.cpp b/modules/lwjgl/yoga/src/main/c/YGNode.cpp
index 2fb4510c5..f4c14bf3d 100644
--- a/modules/lwjgl/yoga/src/main/c/YGNode.cpp
+++ b/modules/lwjgl/yoga/src/main/c/YGNode.cpp
@@ -1,9 +1,10 @@
-/**
+/*
  * Copyright (c) Facebook, Inc. and its affiliates.
  *
- * This source code is licensed under the MIT license found in the LICENSE
- * file in the root directory of this source tree.
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
  */
+
 #include "YGNode.h"
 #include <algorithm>
 #include <iostream>
@@ -15,13 +16,7 @@ using facebook::yoga::detail::CompactValue;
 
 YGNode::YGNode(YGNode&& node) {
   context_ = node.context_;
-  hasNewLayout_ = node.hasNewLayout_;
-  isReferenceBaseline_ = node.isReferenceBaseline_;
-  isDirty_ = node.isDirty_;
-  nodeType_ = node.nodeType_;
-  measureUsesContext_ = node.measureUsesContext_;
-  baselineUsesContext_ = node.baselineUsesContext_;
-  printUsesContext_ = node.printUsesContext_;
+  flags = node.flags;
   measure_ = node.measure_;
   baseline_ = node.baseline_;
   print_ = node.print_;
@@ -34,13 +29,20 @@ YGNode::YGNode(YGNode&& node) {
   config_ = node.config_;
   resolvedDimensions_ = node.resolvedDimensions_;
   for (auto c : children_) {
-    c->setOwner(c);
+    c->setOwner(this);
+  }
+}
+
+YGNode::YGNode(const YGNode& node, YGConfigRef config) : YGNode{node} {
+  config_ = config;
+  if (config->useWebDefaults) {
+    useWebDefaults();
   }
 }
 
 void YGNode::print(void* printContext) {
   if (print_.noContext != nullptr) {
-    if (printUsesContext_) {
+    if (facebook::yoga::detail::getBooleanData(flags, printUsesContext_)) {
       print_.withContext(this, printContext);
     } else {
       print_.noContext(this);
@@ -48,87 +50,111 @@ void YGNode::print(void* printContext) {
   }
 }
 
-YGFloatOptional YGNode::getLeadingPosition(
-    const YGFlexDirection axis,
-    const float axisSize) const {
-  if (YGFlexDirectionIsRow(axis)) {
-    auto leadingPosition = YGComputedEdgeValue(
-        style_.position, YGEdgeStart, CompactValue::ofUndefined());
-    if (!leadingPosition.isUndefined()) {
-      return YGResolveValue(leadingPosition, axisSize);
-    }
+CompactValue YGNode::computeEdgeValueForRow(
+    const YGStyle::Edges& edges,
+    YGEdge rowEdge,
+    YGEdge edge,
+    CompactValue defaultValue) {
+  if (!edges[rowEdge].isUndefined()) {
+    return edges[rowEdge];
+  } else if (!edges[edge].isUndefined()) {
+    return edges[edge];
+  } else if (!edges[YGEdgeHorizontal].isUndefined()) {
+    return edges[YGEdgeHorizontal];
+  } else if (!edges[YGEdgeAll].isUndefined()) {
+    return edges[YGEdgeAll];
+  } else {
+    return defaultValue;
   }
+}
 
-  auto leadingPosition = YGComputedEdgeValue(
-      style_.position, leading[axis], CompactValue::ofUndefined());
+CompactValue YGNode::computeEdgeValueForColumn(
+    const YGStyle::Edges& edges,
+    YGEdge edge,
+    CompactValue defaultValue) {
+  if (!edges[edge].isUndefined()) {
+    return edges[edge];
+  } else if (!edges[YGEdgeVertical].isUndefined()) {
+    return edges[YGEdgeVertical];
+  } else if (!edges[YGEdgeAll].isUndefined()) {
+    return edges[YGEdgeAll];
+  } else {
+    return defaultValue;
+  }
+}
 
-  return leadingPosition.isUndefined()
-      ? YGFloatOptional{0}
-      : YGResolveValue(leadingPosition, axisSize);
+YGFloatOptional YGNode::getLeadingPosition(
+    const YGFlexDirection axis,
+    const float axisSize) const {
+  auto leadingPosition = YGFlexDirectionIsRow(axis)
+      ? computeEdgeValueForRow(
+            style_.position(),
+            YGEdgeStart,
+            leading[axis],
+            CompactValue::ofZero())
+      : computeEdgeValueForColumn(
+            style_.position(), leading[axis], CompactValue::ofZero());
+  return YGResolveValue(leadingPosition, axisSize);
 }
 
 YGFloatOptional YGNode::getTrailingPosition(
     const YGFlexDirection axis,
     const float axisSize) const {
-  if (YGFlexDirectionIsRow(axis)) {
-    auto trailingPosition = YGComputedEdgeValue(
-        style_.position, YGEdgeEnd, CompactValue::ofUndefined());
-    if (!trailingPosition.isUndefined()) {
-      return YGResolveValue(trailingPosition, axisSize);
-    }
-  }
-
-  auto trailingPosition = YGComputedEdgeValue(
-      style_.position, trailing[axis], CompactValue::ofUndefined());
-
-  return trailingPosition.isUndefined()
-      ? YGFloatOptional{0}
-      : YGResolveValue(trailingPosition, axisSize);
+  auto trailingPosition = YGFlexDirectionIsRow(axis)
+      ? computeEdgeValueForRow(
+            style_.position(),
+            YGEdgeEnd,
+            trailing[axis],
+            CompactValue::ofZero())
+      : computeEdgeValueForColumn(
+            style_.position(), trailing[axis], CompactValue::ofZero());
+  return YGResolveValue(trailingPosition, axisSize);
 }
 
 bool YGNode::isLeadingPositionDefined(const YGFlexDirection axis) const {
-  return (YGFlexDirectionIsRow(axis) &&
-          !YGComputedEdgeValue(
-               style_.position, YGEdgeStart, CompactValue::ofUndefined())
-               .isUndefined()) ||
-      !YGComputedEdgeValue(
-           style_.position, leading[axis], CompactValue::ofUndefined())
-           .isUndefined();
+  auto leadingPosition = YGFlexDirectionIsRow(axis)
+      ? computeEdgeValueForRow(
+            style_.position(),
+            YGEdgeStart,
+            leading[axis],
+            CompactValue::ofUndefined())
+      : computeEdgeValueForColumn(
+            style_.position(), leading[axis], CompactValue::ofUndefined());
+  return !leadingPosition.isUndefined();
 }
 
 bool YGNode::isTrailingPosDefined(const YGFlexDirection axis) const {
-  return (YGFlexDirectionIsRow(axis) &&
-          !YGComputedEdgeValue(
-               style_.position, YGEdgeEnd, CompactValue::ofUndefined())
-               .isUndefined()) ||
-      !YGComputedEdgeValue(
-           style_.position, trailing[axis], CompactValue::ofUndefined())
-           .isUndefined();
+  auto trailingPosition = YGFlexDirectionIsRow(axis)
+      ? computeEdgeValueForRow(
+            style_.position(),
+            YGEdgeEnd,
+            trailing[axis],
+            CompactValue::ofUndefined())
+      : computeEdgeValueForColumn(
+            style_.position(), trailing[axis], CompactValue::ofUndefined());
+  return !trailingPosition.isUndefined();
 }
 
 YGFloatOptional YGNode::getLeadingMargin(
     const YGFlexDirection axis,
     const float widthSize) const {
-  if (YGFlexDirectionIsRow(axis) && !style_.margin[YGEdgeStart].isUndefined()) {
-    return YGResolveValueMargin(style_.margin[YGEdgeStart], widthSize);
-  }
-
-  return YGResolveValueMargin(
-      YGComputedEdgeValue(style_.margin, leading[axis], CompactValue::ofZero()),
-      widthSize);
+  auto leadingMargin = YGFlexDirectionIsRow(axis)
+      ? computeEdgeValueForRow(
+            style_.margin(), YGEdgeStart, leading[axis], CompactValue::ofZero())
+      : computeEdgeValueForColumn(
+            style_.margin(), leading[axis], CompactValue::ofZero());
+  return YGResolveValueMargin(leadingMargin, widthSize);
 }
 
 YGFloatOptional YGNode::getTrailingMargin(
     const YGFlexDirection axis,
     const float widthSize) const {
-  if (YGFlexDirectionIsRow(axis) && !style_.margin[YGEdgeEnd].isUndefined()) {
-    return YGResolveValueMargin(style_.margin[YGEdgeEnd], widthSize);
-  }
-
-  return YGResolveValueMargin(
-      YGComputedEdgeValue(
-          style_.margin, trailing[axis], CompactValue::ofZero()),
-      widthSize);
+  auto trailingMargin = YGFlexDirectionIsRow(axis)
+      ? computeEdgeValueForRow(
+            style_.margin(), YGEdgeEnd, trailing[axis], CompactValue::ofZero())
+      : computeEdgeValueForColumn(
+            style_.margin(), trailing[axis], CompactValue::ofZero());
+  return YGResolveValueMargin(trailingMargin, widthSize);
 }
 
 YGFloatOptional YGNode::getMarginForAxis(
@@ -143,15 +169,14 @@ YGSize YGNode::measure(
     float height,
     YGMeasureMode heightMode,
     void* layoutContext) {
-
-  return measureUsesContext_
+  return facebook::yoga::detail::getBooleanData(flags, measureUsesContext_)
       ? measure_.withContext(
             this, width, widthMode, height, heightMode, layoutContext)
       : measure_.noContext(this, width, widthMode, height, heightMode);
 }
 
 float YGNode::baseline(float width, float height, void* layoutContext) {
-  return baselineUsesContext_
+  return facebook::yoga::detail::getBooleanData(flags, baselineUsesContext_)
       ? baseline_.withContext(this, width, height, layoutContext)
       : baseline_.noContext(this, width, height);
 }
@@ -162,7 +187,7 @@ void YGNode::setMeasureFunc(decltype(YGNode::measure_) measureFunc) {
   if (measureFunc.noContext == nullptr) {
     // TODO: t18095186 Move nodeType to opt-in function and mark appropriate
     // places in Litho
-    nodeType_ = YGNodeTypeDefault;
+    setNodeType(YGNodeTypeDefault);
   } else {
     YGAssertWithNode(
         this,
@@ -178,14 +203,14 @@ void YGNode::setMeasureFunc(decltype(YGNode::measure_) measureFunc) {
 }
 
 void YGNode::setMeasureFunc(YGMeasureFunc measureFunc) {
-  measureUsesContext_ = false;
+  facebook::yoga::detail::setBooleanData(flags, measureUsesContext_, false);
   decltype(YGNode::measure_) m;
   m.noContext = measureFunc;
   setMeasureFunc(m);
 }
 
-void YGNode::setMeasureFunc(MeasureWithContextFn measureFunc) {
-  measureUsesContext_ = true;
+YOGA_EXPORT void YGNode::setMeasureFunc(MeasureWithContextFn measureFunc) {
+  facebook::yoga::detail::setBooleanData(flags, measureUsesContext_, true);
   decltype(YGNode::measure_) m;
   m.withContext = measureFunc;
   setMeasureFunc(m);
@@ -204,10 +229,10 @@ void YGNode::insertChild(YGNodeRef child, uint32_t index) {
 }
 
 void YGNode::setDirty(bool isDirty) {
-  if (isDirty == isDirty_) {
+  if (isDirty == facebook::yoga::detail::getBooleanData(flags, isDirty_)) {
     return;
   }
-  isDirty_ = isDirty;
+  facebook::yoga::detail::setBooleanData(flags, isDirty_, isDirty);
   if (isDirty && dirtied_) {
     dirtied_(this);
   }
@@ -228,7 +253,7 @@ void YGNode::removeChild(uint32_t index) {
 }
 
 void YGNode::setLayoutDirection(YGDirection direction) {
-  layout_.direction = direction;
+  layout_.setDirection(direction);
 }
 
 void YGNode::setLayoutMargin(float margin, int index) {
@@ -266,7 +291,7 @@ void YGNode::setLayoutMeasuredDimension(float measuredDimension, int index) {
 }
 
 void YGNode::setLayoutHadOverflow(bool hadOverflow) {
-  layout_.hadOverflow = hadOverflow;
+  layout_.setHadOverflow(hadOverflow);
 }
 
 void YGNode::setLayoutDimension(float dimension, int index) {
@@ -299,10 +324,13 @@ void YGNode::setPosition(
   const YGDirection directionRespectingRoot =
       owner_ != nullptr ? direction : YGDirectionLTR;
   const YGFlexDirection mainAxis =
-      YGResolveFlexDirection(style_.flexDirection, directionRespectingRoot);
+      YGResolveFlexDirection(style_.flexDirection(), directionRespectingRoot);
   const YGFlexDirection crossAxis =
       YGFlexDirectionCross(mainAxis, directionRespectingRoot);
 
+  // Here we should check for `YGPositionTypeStatic` and in this case zero inset
+  // properties (left, right, top, bottom, begin, end).
+  // https://www.w3.org/TR/css-position-3/#valdef-position-static
   const YGFloatOptional relativePositionMain =
       relativePosition(mainAxis, mainSize);
   const YGFloatOptional relativePositionCross =
@@ -325,55 +353,58 @@ void YGNode::setPosition(
 }
 
 YGValue YGNode::marginLeadingValue(const YGFlexDirection axis) const {
-  if (YGFlexDirectionIsRow(axis) && !style_.margin[YGEdgeStart].isUndefined()) {
-    return style_.margin[YGEdgeStart];
+  if (YGFlexDirectionIsRow(axis) &&
+      !style_.margin()[YGEdgeStart].isUndefined()) {
+    return style_.margin()[YGEdgeStart];
   } else {
-    return style_.margin[leading[axis]];
+    return style_.margin()[leading[axis]];
   }
 }
 
 YGValue YGNode::marginTrailingValue(const YGFlexDirection axis) const {
-  if (YGFlexDirectionIsRow(axis) && !style_.margin[YGEdgeEnd].isUndefined()) {
-    return style_.margin[YGEdgeEnd];
+  if (YGFlexDirectionIsRow(axis) && !style_.margin()[YGEdgeEnd].isUndefined()) {
+    return style_.margin()[YGEdgeEnd];
   } else {
-    return style_.margin[trailing[axis]];
+    return style_.margin()[trailing[axis]];
   }
 }
 
 YGValue YGNode::resolveFlexBasisPtr() const {
-  YGValue flexBasis = style_.flexBasis;
+  YGValue flexBasis = style_.flexBasis();
   if (flexBasis.unit != YGUnitAuto && flexBasis.unit != YGUnitUndefined) {
     return flexBasis;
   }
-  if (!style_.flex.isUndefined() && style_.flex.unwrap() > 0.0f) {
-    return config_->useWebDefaults ? YGValueAuto : YGValueZero;
+  if (!style_.flex().isUndefined() && style_.flex().unwrap() > 0.0f) {
+    return facebook::yoga::detail::getBooleanData(flags, useWebDefaults_)
+        ? YGValueAuto
+        : YGValueZero;
   }
   return YGValueAuto;
 }
 
 void YGNode::resolveDimension() {
   using namespace yoga;
-  for (int dim = YGDimensionWidth; dim < enums::count<YGDimension>(); dim++) {
-    if (!getStyle().maxDimensions[dim].isUndefined() &&
-        YGValueEqual(
-            getStyle().maxDimensions[dim], style_.minDimensions[dim])) {
-      resolvedDimensions_[dim] = style_.maxDimensions[dim];
+  const YGStyle& style = getStyle();
+  for (auto dim : {YGDimensionWidth, YGDimensionHeight}) {
+    if (!style.maxDimensions()[dim].isUndefined() &&
+        YGValueEqual(style.maxDimensions()[dim], style.minDimensions()[dim])) {
+      resolvedDimensions_[dim] = style.maxDimensions()[dim];
     } else {
-      resolvedDimensions_[dim] = style_.dimensions[dim];
+      resolvedDimensions_[dim] = style.dimensions()[dim];
     }
   }
 }
 
 YGDirection YGNode::resolveDirection(const YGDirection ownerDirection) {
-  if (style_.direction == YGDirectionInherit) {
+  if (style_.direction() == YGDirectionInherit) {
     return ownerDirection > YGDirectionInherit ? ownerDirection
                                                : YGDirectionLTR;
   } else {
-    return style_.direction;
+    return style_.direction();
   }
 }
 
-void YGNode::clearChildren() {
+YOGA_EXPORT void YGNode::clearChildren() {
   children_.clear();
   children_.shrink_to_fit();
 }
@@ -385,7 +416,7 @@ void YGNode::cloneChildrenIfNeeded(void* cloneContext) {
 }
 
 void YGNode::markDirtyAndPropogate() {
-  if (!isDirty_) {
+  if (!facebook::yoga::detail::getBooleanData(flags, isDirty_)) {
     setDirty(true);
     setLayoutComputedFlexBasis(YGFloatOptional());
     if (owner_) {
@@ -395,108 +426,91 @@ void YGNode::markDirtyAndPropogate() {
 }
 
 void YGNode::markDirtyAndPropogateDownwards() {
-  isDirty_ = true;
+  facebook::yoga::detail::setBooleanData(flags, isDirty_, true);
   for_each(children_.begin(), children_.end(), [](YGNodeRef childNode) {
     childNode->markDirtyAndPropogateDownwards();
   });
 }
 
-float YGNode::resolveFlexGrow() {
+float YGNode::resolveFlexGrow() const {
   // Root nodes flexGrow should always be 0
   if (owner_ == nullptr) {
     return 0.0;
   }
-  if (!style_.flexGrow.isUndefined()) {
-    return style_.flexGrow.unwrap();
+  if (!style_.flexGrow().isUndefined()) {
+    return style_.flexGrow().unwrap();
   }
-  if (!style_.flex.isUndefined() && style_.flex.unwrap() > 0.0f) {
-    return style_.flex.unwrap();
+  if (!style_.flex().isUndefined() && style_.flex().unwrap() > 0.0f) {
+    return style_.flex().unwrap();
   }
   return kDefaultFlexGrow;
 }
 
-float YGNode::resolveFlexShrink() {
+float YGNode::resolveFlexShrink() const {
   if (owner_ == nullptr) {
     return 0.0;
   }
-  if (!style_.flexShrink.isUndefined()) {
-    return style_.flexShrink.unwrap();
+  if (!style_.flexShrink().isUndefined()) {
+    return style_.flexShrink().unwrap();
   }
-  if (!config_->useWebDefaults && !style_.flex.isUndefined() &&
-      style_.flex.unwrap() < 0.0f) {
-    return -style_.flex.unwrap();
+  if (!facebook::yoga::detail::getBooleanData(flags, useWebDefaults_) &&
+      !style_.flex().isUndefined() && style_.flex().unwrap() < 0.0f) {
+    return -style_.flex().unwrap();
   }
-  return config_->useWebDefaults ? kWebDefaultFlexShrink : kDefaultFlexShrink;
+  return facebook::yoga::detail::getBooleanData(flags, useWebDefaults_)
+      ? kWebDefaultFlexShrink
+      : kDefaultFlexShrink;
 }
 
 bool YGNode::isNodeFlexible() {
   return (
-      (style_.positionType == YGPositionTypeRelative) &&
+      (style_.positionType() != YGPositionTypeAbsolute) &&
       (resolveFlexGrow() != 0 || resolveFlexShrink() != 0));
 }
 
 float YGNode::getLeadingBorder(const YGFlexDirection axis) const {
-  YGValue leadingBorder;
-  if (YGFlexDirectionIsRow(axis) && !style_.border[YGEdgeStart].isUndefined()) {
-    leadingBorder = style_.border[YGEdgeStart];
-    if (leadingBorder.value >= 0) {
-      return leadingBorder.value;
-    }
-  }
-
-  leadingBorder =
-      YGComputedEdgeValue(style_.border, leading[axis], CompactValue::ofZero());
-  return YGFloatMax(leadingBorder.value, 0.0f);
+  YGValue leadingBorder = YGFlexDirectionIsRow(axis)
+      ? computeEdgeValueForRow(
+            style_.border(), YGEdgeStart, leading[axis], CompactValue::ofZero())
+      : computeEdgeValueForColumn(
+            style_.border(), leading[axis], CompactValue::ofZero());
+  return fmaxf(leadingBorder.value, 0.0f);
 }
 
-float YGNode::getTrailingBorder(const YGFlexDirection flexDirection) const {
-  YGValue trailingBorder;
-  if (YGFlexDirectionIsRow(flexDirection) &&
-      !style_.border[YGEdgeEnd].isUndefined()) {
-    trailingBorder = style_.border[YGEdgeEnd];
-    if (trailingBorder.value >= 0.0f) {
-      return trailingBorder.value;
-    }
-  }
-
-  trailingBorder = YGComputedEdgeValue(
-      style_.border, trailing[flexDirection], CompactValue::ofZero());
-  return YGFloatMax(trailingBorder.value, 0.0f);
+float YGNode::getTrailingBorder(const YGFlexDirection axis) const {
+  YGValue trailingBorder = YGFlexDirectionIsRow(axis)
+      ? computeEdgeValueForRow(
+            style_.border(), YGEdgeEnd, trailing[axis], CompactValue::ofZero())
+      : computeEdgeValueForColumn(
+            style_.border(), trailing[axis], CompactValue::ofZero());
+  return fmaxf(trailingBorder.value, 0.0f);
 }
 
 YGFloatOptional YGNode::getLeadingPadding(
     const YGFlexDirection axis,
     const float widthSize) const {
-  const YGFloatOptional paddingEdgeStart =
-      YGResolveValue(style_.padding[YGEdgeStart], widthSize);
-  if (YGFlexDirectionIsRow(axis) &&
-      !style_.padding[YGEdgeStart].isUndefined() &&
-      !paddingEdgeStart.isUndefined() && paddingEdgeStart.unwrap() >= 0.0f) {
-    return paddingEdgeStart;
-  }
-
-  YGFloatOptional resolvedValue = YGResolveValue(
-      YGComputedEdgeValue(
-          style_.padding, leading[axis], CompactValue::ofZero()),
-      widthSize);
-  return YGFloatOptionalMax(resolvedValue, YGFloatOptional(0.0f));
+  auto leadingPadding = YGFlexDirectionIsRow(axis)
+      ? computeEdgeValueForRow(
+            style_.padding(),
+            YGEdgeStart,
+            leading[axis],
+            CompactValue::ofZero())
+      : computeEdgeValueForColumn(
+            style_.padding(), leading[axis], CompactValue::ofZero());
+  return YGFloatOptionalMax(
+      YGResolveValue(leadingPadding, widthSize), YGFloatOptional(0.0f));
 }
 
 YGFloatOptional YGNode::getTrailingPadding(
     const YGFlexDirection axis,
     const float widthSize) const {
-  const YGFloatOptional paddingEdgeEnd =
-      YGResolveValue(style_.padding[YGEdgeEnd], widthSize);
-  if (YGFlexDirectionIsRow(axis) && paddingEdgeEnd >= YGFloatOptional{0.0f}) {
-    return paddingEdgeEnd;
-  }
-
-  YGFloatOptional resolvedValue = YGResolveValue(
-      YGComputedEdgeValue(
-          style_.padding, trailing[axis], CompactValue::ofZero()),
-      widthSize);
-
-  return YGFloatOptionalMax(resolvedValue, YGFloatOptional(0.0f));
+  auto trailingPadding = YGFlexDirectionIsRow(axis)
+      ? computeEdgeValueForRow(
+            style_.padding(), YGEdgeEnd, trailing[axis], CompactValue::ofZero())
+      : computeEdgeValueForColumn(
+            style_.padding(), trailing[axis], CompactValue::ofZero());
+  return YGFloatOptionalMax(
+      YGResolveValue(trailingPadding, widthSize), YGFloatOptional(0.0f));
 }
 
 YGFloatOptional YGNode::getLeadingPaddingAndBorder(
@@ -514,12 +528,12 @@ YGFloatOptional YGNode::getTrailingPaddingAndBorder(
 }
 
 bool YGNode::didUseLegacyFlag() {
-  bool didUseLegacyFlag = layout_.didUseLegacyFlag;
+  bool didUseLegacyFlag = layout_.didUseLegacyFlag();
   if (didUseLegacyFlag) {
     return true;
   }
   for (const auto& child : children_) {
-    if (child->layout_.didUseLegacyFlag) {
+    if (child->layout_.didUseLegacyFlag()) {
       didUseLegacyFlag = true;
       break;
     }
@@ -527,20 +541,13 @@ bool YGNode::didUseLegacyFlag() {
   return didUseLegacyFlag;
 }
 
-void YGNode::setAndPropogateUseLegacyFlag(bool useLegacyFlag) {
-  config_->useLegacyStretchBehaviour = useLegacyFlag;
-  for_each(children_.begin(), children_.end(), [=](YGNodeRef childNode) {
-    childNode->getConfig()->useLegacyStretchBehaviour = useLegacyFlag;
-  });
-}
-
 void YGNode::setLayoutDoesLegacyFlagAffectsLayout(
     bool doesLegacyFlagAffectsLayout) {
-  layout_.doesLegacyStretchFlagAffectsLayout = doesLegacyFlagAffectsLayout;
+  layout_.setDoesLegacyStretchFlagAffectsLayout(doesLegacyFlagAffectsLayout);
 }
 
 void YGNode::setLayoutDidUseLegacyFlag(bool didUseLegacyFlag) {
-  layout_.didUseLegacyFlag = didUseLegacyFlag;
+  layout_.setDidUseLegacyFlag(didUseLegacyFlag);
 }
 
 bool YGNode::isLayoutTreeEqualToNode(const YGNode& node) const {
@@ -577,11 +584,10 @@ void YGNode::reset() {
 
   clearChildren();
 
-  auto config = getConfig();
-  *this = YGNode{};
-  if (config->useWebDefaults) {
-    setStyleFlexDirection(YGFlexDirectionRow);
-    setStyleAlignContent(YGAlignStretch);
+  auto webDefaults =
+      facebook::yoga::detail::getBooleanData(flags, useWebDefaults_);
+  *this = YGNode{getConfig()};
+  if (webDefaults) {
+    useWebDefaults();
   }
-  setConfig(config);
 }
diff --git a/modules/lwjgl/yoga/src/main/c/YGNode.h b/modules/lwjgl/yoga/src/main/c/YGNode.h
index b5ff98a5c..4b6e6277a 100644
--- a/modules/lwjgl/yoga/src/main/c/YGNode.h
+++ b/modules/lwjgl/yoga/src/main/c/YGNode.h
@@ -1,31 +1,45 @@
-/**
+/*
  * Copyright (c) Facebook, Inc. and its affiliates.
  *
- * This source code is licensed under the MIT license found in the LICENSE
- * file in the root directory of this source tree.
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
  */
+
 #pragma once
+
+#ifdef __cplusplus
+
+#include <cstdint>
 #include <stdio.h>
+#include "BitUtils.h"
+#include "CompactValue.h"
 #include "YGConfig.h"
 #include "YGLayout.h"
 #include "YGStyle.h"
+#include "YGMacros.h"
 #include "Yoga-internal.h"
 
-struct YGNode {
+YGConfigRef YGConfigGetDefault();
+
+struct YOGA_EXPORT YGNode {
   using MeasureWithContextFn =
       YGSize (*)(YGNode*, float, YGMeasureMode, float, YGMeasureMode, void*);
   using BaselineWithContextFn = float (*)(YGNode*, float, float, void*);
   using PrintWithContextFn = void (*)(YGNode*, void*);
 
 private:
+  static constexpr size_t hasNewLayout_ = 0;
+  static constexpr size_t isReferenceBaseline_ = 1;
+  static constexpr size_t isDirty_ = 2;
+  static constexpr size_t nodeType_ = 3;
+  static constexpr size_t measureUsesContext_ = 4;
+  static constexpr size_t baselineUsesContext_ = 5;
+  static constexpr size_t printUsesContext_ = 6;
+  static constexpr size_t useWebDefaults_ = 7;
+
   void* context_ = nullptr;
-  bool hasNewLayout_ : 1;
-  bool isReferenceBaseline_ : 1;
-  bool isDirty_ : 1;
-  YGNodeType nodeType_ : 1;
-  bool measureUsesContext_ : 1;
-  bool baselineUsesContext_ : 1;
-  bool printUsesContext_ : 1;
+  uint8_t flags = 1;
+  uint8_t reserved_ = 0;
   union {
     YGMeasureFunc noContext;
     MeasureWithContextFn withContext;
@@ -44,7 +58,7 @@ private:
   uint32_t lineIndex_ = 0;
   YGNodeRef owner_ = nullptr;
   YGVector children_ = {};
-  YGConfigRef config_ = nullptr;
+  YGConfigRef config_;
   std::array<YGValue, 2> resolvedDimensions_ = {
       {YGValueUndefined, YGValueUndefined}};
 
@@ -55,24 +69,29 @@ private:
   void setMeasureFunc(decltype(measure_));
   void setBaselineFunc(decltype(baseline_));
 
+  void useWebDefaults() {
+    facebook::yoga::detail::setBooleanData(flags, useWebDefaults_, true);
+    style_.flexDirection() = YGFlexDirectionRow;
+    style_.alignContent() = YGAlignStretch;
+  }
+
   // DANGER DANGER DANGER!
-  // If the the node assigned to has children, we'd either have to deallocate
+  // If the node assigned to has children, we'd either have to deallocate
   // them (potentially incorrect) or ignore them (danger of leaks). Only ever
   // use this after checking that there are no children.
   // DO NOT CHANGE THE VISIBILITY OF THIS METHOD!
   YGNode& operator=(YGNode&&) = default;
 
+  using CompactValue = facebook::yoga::detail::CompactValue;
+
 public:
-  YGNode()
-      : hasNewLayout_{true},
-        isReferenceBaseline_{false},
-        isDirty_{false},
-        nodeType_{YGNodeTypeDefault},
-        measureUsesContext_{false},
-        baselineUsesContext_{false},
-        printUsesContext_{false} {}
+  YGNode() : YGNode{YGConfigGetDefault()} {}
+  explicit YGNode(const YGConfigRef config) : config_{config} {
+    if (config->useWebDefaults) {
+      useWebDefaults();
+    }
+  };
   ~YGNode() = default; // cleanup of owner/children relationships in YGNodeFree
-  explicit YGNode(const YGConfigRef newConfig) : config_(newConfig){};
 
   YGNode(YGNode&&);
 
@@ -80,28 +99,30 @@ public:
   // Should we remove this?
   YGNode(const YGNode& node) = default;
 
+  // for RB fabric
+  YGNode(const YGNode& node, YGConfigRef config);
+
   // assignment means potential leaks of existing children, or alternatively
   // freeing unowned memory, double free, or freeing stack memory.
   YGNode& operator=(const YGNode&) = delete;
 
   // Getters
-  void* getContext() const {
-    return context_;
-  }
+  void* getContext() const { return context_; }
+
+  uint8_t& reserved() { return reserved_; }
+  uint8_t reserved() const { return reserved_; }
 
   void print(void*);
 
   bool getHasNewLayout() const {
-    return hasNewLayout_;
+    return facebook::yoga::detail::getBooleanData(flags, hasNewLayout_);
   }
 
   YGNodeType getNodeType() const {
-    return nodeType_;
+    return facebook::yoga::detail::getEnumData<YGNodeType>(flags, nodeType_);
   }
 
-  bool hasMeasureFunc() const noexcept {
-    return measure_.noContext != nullptr;
-  }
+  bool hasMeasureFunc() const noexcept { return measure_.noContext != nullptr; }
 
   YGSize measure(float, YGMeasureMode, float, YGMeasureMode, void*);
 
@@ -111,52 +132,34 @@ public:
 
   float baseline(float width, float height, void* layoutContext);
 
-  YGDirtiedFunc getDirtied() const {
-    return dirtied_;
-  }
+  YGDirtiedFunc getDirtied() const { return dirtied_; }
 
   // For Performance reasons passing as reference.
-  YGStyle& getStyle() {
-    return style_;
-  }
+  YGStyle& getStyle() { return style_; }
 
-  const YGStyle& getStyle() const {
-    return style_;
-  }
+  const YGStyle& getStyle() const { return style_; }
 
   // For Performance reasons passing as reference.
-  YGLayout& getLayout() {
-    return layout_;
-  }
+  YGLayout& getLayout() { return layout_; }
 
-  const YGLayout& getLayout() const {
-    return layout_;
-  }
+  const YGLayout& getLayout() const { return layout_; }
 
-  uint32_t getLineIndex() const {
-    return lineIndex_;
-  }
+  uint32_t getLineIndex() const { return lineIndex_; }
 
   bool isReferenceBaseline() {
-    return isReferenceBaseline_;
+    return facebook::yoga::detail::getBooleanData(flags, isReferenceBaseline_);
   }
 
   // returns the YGNodeRef that owns this YGNode. An owner is used to identify
   // the YogaTree that a YGNode belongs to. This method will return the parent
   // of the YGNode when a YGNode only belongs to one YogaTree or nullptr when
   // the YGNode is shared between two or more YogaTrees.
-  YGNodeRef getOwner() const {
-    return owner_;
-  }
+  YGNodeRef getOwner() const { return owner_; }
 
   // Deprecated, use getOwner() instead.
-  YGNodeRef getParent() const {
-    return getOwner();
-  }
+  YGNodeRef getParent() const { return getOwner(); }
 
-  const YGVector& getChildren() const {
-    return children_;
-  }
+  const YGVector& getChildren() const { return children_; }
 
   // Applies a callback to all children, after cloning them if they are not
   // owned.
@@ -174,16 +177,12 @@ public:
     }
   }
 
-  YGNodeRef getChild(uint32_t index) const {
-    return children_.at(index);
-  }
+  YGNodeRef getChild(uint32_t index) const { return children_.at(index); }
 
-  YGConfigRef getConfig() const {
-    return config_;
-  }
+  YGConfigRef getConfig() const { return config_; }
 
   bool isDirty() const {
-    return isDirty_;
+    return facebook::yoga::detail::getBooleanData(flags, isDirty_);
   }
 
   std::array<YGValue, 2> getResolvedDimensions() const {
@@ -194,6 +193,17 @@ public:
     return resolvedDimensions_[index];
   }
 
+  static CompactValue computeEdgeValueForColumn(
+      const YGStyle::Edges& edges,
+      YGEdge edge,
+      CompactValue defaultValue);
+
+  static CompactValue computeEdgeValueForRow(
+      const YGStyle::Edges& edges,
+      YGEdge rowEdge,
+      YGEdge edge,
+      CompactValue defaultValue);
+
   // Methods related to positions, margin, padding and border
   YGFloatOptional getLeadingPosition(
       const YGFlexDirection axis,
@@ -228,36 +238,25 @@ public:
       const float widthSize) const;
   // Setters
 
-  void setContext(void* context) {
-    context_ = context;
-  }
+  void setContext(void* context) { context_ = context; }
 
   void setPrintFunc(YGPrintFunc printFunc) {
     print_.noContext = printFunc;
-    printUsesContext_ = false;
+    facebook::yoga::detail::setBooleanData(flags, printUsesContext_, false);
   }
   void setPrintFunc(PrintWithContextFn printFunc) {
     print_.withContext = printFunc;
-    printUsesContext_ = true;
-  }
-  void setPrintFunc(std::nullptr_t) {
-    setPrintFunc(YGPrintFunc{nullptr});
+    facebook::yoga::detail::setBooleanData(flags, printUsesContext_, true);
   }
+  void setPrintFunc(std::nullptr_t) { setPrintFunc(YGPrintFunc{nullptr}); }
 
   void setHasNewLayout(bool hasNewLayout) {
-    hasNewLayout_ = hasNewLayout;
+    facebook::yoga::detail::setBooleanData(flags, hasNewLayout_, hasNewLayout);
   }
 
   void setNodeType(YGNodeType nodeType) {
-    nodeType_ = nodeType;
-  }
-
-  void setStyleFlexDirection(YGFlexDirection direction) {
-    style_.flexDirection = direction;
-  }
-
-  void setStyleAlignContent(YGAlign alignContent) {
-    style_.alignContent = alignContent;
+    return facebook::yoga::detail::setEnumData<YGNodeType>(
+        flags, nodeType_, nodeType);
   }
 
   void setMeasureFunc(YGMeasureFunc measureFunc);
@@ -267,50 +266,37 @@ public:
   }
 
   void setBaselineFunc(YGBaselineFunc baseLineFunc) {
-    baselineUsesContext_ = false;
+    facebook::yoga::detail::setBooleanData(flags, baselineUsesContext_, false);
     baseline_.noContext = baseLineFunc;
   }
   void setBaselineFunc(BaselineWithContextFn baseLineFunc) {
-    baselineUsesContext_ = true;
+    facebook::yoga::detail::setBooleanData(flags, baselineUsesContext_, true);
     baseline_.withContext = baseLineFunc;
   }
   void setBaselineFunc(std::nullptr_t) {
     return setBaselineFunc(YGBaselineFunc{nullptr});
   }
 
-  void setDirtiedFunc(YGDirtiedFunc dirtiedFunc) {
-    dirtied_ = dirtiedFunc;
-  }
+  void setDirtiedFunc(YGDirtiedFunc dirtiedFunc) { dirtied_ = dirtiedFunc; }
 
-  void setStyle(const YGStyle& style) {
-    style_ = style;
-  }
+  void setStyle(const YGStyle& style) { style_ = style; }
 
-  void setLayout(const YGLayout& layout) {
-    layout_ = layout;
-  }
+  void setLayout(const YGLayout& layout) { layout_ = layout; }
 
-  void setLineIndex(uint32_t lineIndex) {
-    lineIndex_ = lineIndex;
-  }
+  void setLineIndex(uint32_t lineIndex) { lineIndex_ = lineIndex; }
 
   void setIsReferenceBaseline(bool isReferenceBaseline) {
-    isReferenceBaseline_ = isReferenceBaseline;
+    facebook::yoga::detail::setBooleanData(
+        flags, isReferenceBaseline_, isReferenceBaseline);
   }
 
-  void setOwner(YGNodeRef owner) {
-    owner_ = owner;
-  }
+  void setOwner(YGNodeRef owner) { owner_ = owner; }
 
-  void setChildren(const YGVector& children) {
-    children_ = children;
-  }
+  void setChildren(const YGVector& children) { children_ = children; }
 
   // TODO: rvalue override for setChildren
 
-  void setConfig(YGConfigRef config) {
-    config_ = config;
-  }
+  YG_DEPRECATED void setConfig(YGConfigRef config) { config_ = config; }
 
   void setDirty(bool isDirty);
   void setLayoutLastOwnerDirection(YGDirection direction);
@@ -330,7 +316,6 @@ public:
       const float mainSize,
       const float crossSize,
       const float ownerWidth);
-  void setAndPropogateUseLegacyFlag(bool useLegacyFlag);
   void setLayoutDoesLegacyFlagAffectsLayout(bool doesLegacyFlagAffectsLayout);
   void setLayoutDidUseLegacyFlag(bool didUseLegacyFlag);
   void markDirtyAndPropogateDownwards();
@@ -352,10 +337,12 @@ public:
 
   void cloneChildrenIfNeeded(void*);
   void markDirtyAndPropogate();
-  float resolveFlexGrow();
-  float resolveFlexShrink();
+  float resolveFlexGrow() const;
+  float resolveFlexShrink() const;
   bool isNodeFlexible();
   bool didUseLegacyFlag();
   bool isLayoutTreeEqualToNode(const YGNode& node) const;
   void reset();
 };
+
+#endif
diff --git a/modules/lwjgl/yoga/src/main/c/YGNodePrint.cpp b/modules/lwjgl/yoga/src/main/c/YGNodePrint.cpp
index cc3ead743..72d147dbb 100644
--- a/modules/lwjgl/yoga/src/main/c/YGNodePrint.cpp
+++ b/modules/lwjgl/yoga/src/main/c/YGNodePrint.cpp
@@ -1,9 +1,10 @@
-/**
+/*
  * Copyright (c) Facebook, Inc. and its affiliates.
  *
- * This source code is licensed under the MIT license found in the LICENSE
- * file in the root directory of this source tree.
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
  */
+
 #ifdef DEBUG
 #include "YGNodePrint.h"
 #include <stdarg.h>
@@ -103,10 +104,13 @@ static void appendEdgeIfNotUndefined(
     const string& str,
     const YGStyle::Edges& edges,
     const YGEdge edge) {
-  appendNumberIfNotUndefined(
-      base,
-      str,
-      YGComputedEdgeValue(edges, edge, detail::CompactValue::ofUndefined()));
+  // TODO: this doesn't take RTL / YGEdgeStart / YGEdgeEnd into account
+  auto value = (edge == YGEdgeLeft || edge == YGEdgeRight)
+      ? YGNode::computeEdgeValueForRow(
+            edges, edge, edge, detail::CompactValue::ofUndefined())
+      : YGNode::computeEdgeValueForColumn(
+            edges, edge, detail::CompactValue::ofUndefined());
+  appendNumberIfNotUndefined(base, str, value);
 }
 
 void YGNodeToString(
@@ -132,85 +136,74 @@ void YGNodeToString(
 
   if (options & YGPrintOptionsStyle) {
     appendFormatedString(str, "style=\"");
-    if (node->getStyle().flexDirection != YGNode().getStyle().flexDirection) {
+    const auto& style = node->getStyle();
+    if (style.flexDirection() != YGNode().getStyle().flexDirection()) {
       appendFormatedString(
           str,
           "flex-direction: %s; ",
-          YGFlexDirectionToString(node->getStyle().flexDirection));
+          YGFlexDirectionToString(style.flexDirection()));
     }
-    if (node->getStyle().justifyContent != YGNode().getStyle().justifyContent) {
+    if (style.justifyContent() != YGNode().getStyle().justifyContent()) {
       appendFormatedString(
           str,
           "justify-content: %s; ",
-          YGJustifyToString(node->getStyle().justifyContent));
+          YGJustifyToString(style.justifyContent()));
     }
-    if (node->getStyle().alignItems != YGNode().getStyle().alignItems) {
+    if (style.alignItems() != YGNode().getStyle().alignItems()) {
       appendFormatedString(
-          str,
-          "align-items: %s; ",
-          YGAlignToString(node->getStyle().alignItems));
+          str, "align-items: %s; ", YGAlignToString(style.alignItems()));
     }
-    if (node->getStyle().alignContent != YGNode().getStyle().alignContent) {
+    if (style.alignContent() != YGNode().getStyle().alignContent()) {
       appendFormatedString(
-          str,
-          "align-content: %s; ",
-          YGAlignToString(node->getStyle().alignContent));
+          str, "align-content: %s; ", YGAlignToString(style.alignContent()));
     }
-    if (node->getStyle().alignSelf != YGNode().getStyle().alignSelf) {
+    if (style.alignSelf() != YGNode().getStyle().alignSelf()) {
       appendFormatedString(
-          str, "align-self: %s; ", YGAlignToString(node->getStyle().alignSelf));
+          str, "align-self: %s; ", YGAlignToString(style.alignSelf()));
     }
-    appendFloatOptionalIfDefined(str, "flex-grow", node->getStyle().flexGrow);
-    appendFloatOptionalIfDefined(
-        str, "flex-shrink", node->getStyle().flexShrink);
-    appendNumberIfNotAuto(str, "flex-basis", node->getStyle().flexBasis);
-    appendFloatOptionalIfDefined(str, "flex", node->getStyle().flex);
+    appendFloatOptionalIfDefined(str, "flex-grow", style.flexGrow());
+    appendFloatOptionalIfDefined(str, "flex-shrink", style.flexShrink());
+    appendNumberIfNotAuto(str, "flex-basis", style.flexBasis());
+    appendFloatOptionalIfDefined(str, "flex", style.flex());
 
-    if (node->getStyle().flexWrap != YGNode().getStyle().flexWrap) {
+    if (style.flexWrap() != YGNode().getStyle().flexWrap()) {
       appendFormatedString(
-          str, "flex-wrap: %s; ", YGWrapToString(node->getStyle().flexWrap));
+          str, "flex-wrap: %s; ", YGWrapToString(style.flexWrap()));
     }
 
-    if (node->getStyle().overflow != YGNode().getStyle().overflow) {
+    if (style.overflow() != YGNode().getStyle().overflow()) {
       appendFormatedString(
-          str, "overflow: %s; ", YGOverflowToString(node->getStyle().overflow));
+          str, "overflow: %s; ", YGOverflowToString(style.overflow()));
     }
 
-    if (node->getStyle().display != YGNode().getStyle().display) {
+    if (style.display() != YGNode().getStyle().display()) {
       appendFormatedString(
-          str, "display: %s; ", YGDisplayToString(node->getStyle().display));
+          str, "display: %s; ", YGDisplayToString(style.display()));
     }
-    appendEdges(str, "margin", node->getStyle().margin);
-    appendEdges(str, "padding", node->getStyle().padding);
-    appendEdges(str, "border", node->getStyle().border);
+    appendEdges(str, "margin", style.margin());
+    appendEdges(str, "padding", style.padding());
+    appendEdges(str, "border", style.border());
 
+    appendNumberIfNotAuto(str, "width", style.dimensions()[YGDimensionWidth]);
+    appendNumberIfNotAuto(str, "height", style.dimensions()[YGDimensionHeight]);
     appendNumberIfNotAuto(
-        str, "width", node->getStyle().dimensions[YGDimensionWidth]);
+        str, "max-width", style.maxDimensions()[YGDimensionWidth]);
     appendNumberIfNotAuto(
-        str, "height", node->getStyle().dimensions[YGDimensionHeight]);
+        str, "max-height", style.maxDimensions()[YGDimensionHeight]);
     appendNumberIfNotAuto(
-        str, "max-width", node->getStyle().maxDimensions[YGDimensionWidth]);
+        str, "min-width", style.minDimensions()[YGDimensionWidth]);
     appendNumberIfNotAuto(
-        str, "max-height", node->getStyle().maxDimensions[YGDimensionHeight]);
-    appendNumberIfNotAuto(
-        str, "min-width", node->getStyle().minDimensions[YGDimensionWidth]);
-    appendNumberIfNotAuto(
-        str, "min-height", node->getStyle().minDimensions[YGDimensionHeight]);
+        str, "min-height", style.minDimensions()[YGDimensionHeight]);
 
-    if (node->getStyle().positionType != YGNode().getStyle().positionType) {
+    if (style.positionType() != YGNode().getStyle().positionType()) {
       appendFormatedString(
-          str,
-          "position: %s; ",
-          YGPositionTypeToString(node->getStyle().positionType));
+          str, "position: %s; ", YGPositionTypeToString(style.positionType()));
     }
 
-    appendEdgeIfNotUndefined(
-        str, "left", node->getStyle().position, YGEdgeLeft);
-    appendEdgeIfNotUndefined(
-        str, "right", node->getStyle().position, YGEdgeRight);
-    appendEdgeIfNotUndefined(str, "top", node->getStyle().position, YGEdgeTop);
-    appendEdgeIfNotUndefined(
-        str, "bottom", node->getStyle().position, YGEdgeBottom);
+    appendEdgeIfNotUndefined(str, "left", style.position(), YGEdgeLeft);
+    appendEdgeIfNotUndefined(str, "right", style.position(), YGEdgeRight);
+    appendEdgeIfNotUndefined(str, "top", style.position(), YGEdgeTop);
+    appendEdgeIfNotUndefined(str, "bottom", style.position(), YGEdgeBottom);
     appendFormatedString(str, "\" ");
 
     if (node->hasMeasureFunc()) {
diff --git a/modules/lwjgl/yoga/src/main/c/YGNodePrint.h b/modules/lwjgl/yoga/src/main/c/YGNodePrint.h
index 13cf367b5..3db504b46 100644
--- a/modules/lwjgl/yoga/src/main/c/YGNodePrint.h
+++ b/modules/lwjgl/yoga/src/main/c/YGNodePrint.h
@@ -1,9 +1,10 @@
-/**
+/*
  * Copyright (c) Facebook, Inc. and its affiliates.
  *
- * This source code is licensed under the MIT license found in the LICENSE
- * file in the root directory of this source tree.
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
  */
+
 #ifdef DEBUG
 #pragma once
 #include <string>
diff --git a/modules/lwjgl/yoga/src/main/c/YGStyle.cpp b/modules/lwjgl/yoga/src/main/c/YGStyle.cpp
index 26b0f2696..e8033bdf4 100644
--- a/modules/lwjgl/yoga/src/main/c/YGStyle.cpp
+++ b/modules/lwjgl/yoga/src/main/c/YGStyle.cpp
@@ -1,51 +1,55 @@
-/**
+/*
  * Copyright (c) Facebook, Inc. and its affiliates.
  *
- * This source code is licensed under the MIT license found in the LICENSE
- * file in the root directory of this source tree.
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
  */
+
 #include "YGStyle.h"
 #include "Utils.h"
 
 // Yoga specific properties, not compatible with flexbox specification
 bool operator==(const YGStyle& lhs, const YGStyle& rhs) {
-  bool areNonFloatValuesEqual = lhs.direction == rhs.direction &&
-      lhs.flexDirection == rhs.flexDirection &&
-      lhs.justifyContent == rhs.justifyContent &&
-      lhs.alignContent == rhs.alignContent &&
-      lhs.alignItems == rhs.alignItems && lhs.alignSelf == rhs.alignSelf &&
-      lhs.positionType == rhs.positionType && lhs.flexWrap == rhs.flexWrap &&
-      lhs.overflow == rhs.overflow && lhs.display == rhs.display &&
-      YGValueEqual(lhs.flexBasis, rhs.flexBasis) && lhs.margin == rhs.margin &&
-      lhs.position == rhs.position && lhs.padding == rhs.padding &&
-      lhs.border == rhs.border && lhs.dimensions == rhs.dimensions &&
-      lhs.minDimensions == rhs.minDimensions &&
-      lhs.maxDimensions == rhs.maxDimensions;
+  bool areNonFloatValuesEqual = lhs.direction() == rhs.direction() &&
+      lhs.flexDirection() == rhs.flexDirection() &&
+      lhs.justifyContent() == rhs.justifyContent() &&
+      lhs.alignContent() == rhs.alignContent() &&
+      lhs.alignItems() == rhs.alignItems() &&
+      lhs.alignSelf() == rhs.alignSelf() &&
+      lhs.positionType() == rhs.positionType() &&
+      lhs.flexWrap() == rhs.flexWrap() && lhs.overflow() == rhs.overflow() &&
+      lhs.display() == rhs.display() &&
+      YGValueEqual(lhs.flexBasis(), rhs.flexBasis()) &&
+      lhs.margin() == rhs.margin() && lhs.position() == rhs.position() &&
+      lhs.padding() == rhs.padding() && lhs.border() == rhs.border() &&
+      lhs.dimensions() == rhs.dimensions() &&
+      lhs.minDimensions() == rhs.minDimensions() &&
+      lhs.maxDimensions() == rhs.maxDimensions();
 
   areNonFloatValuesEqual = areNonFloatValuesEqual &&
-      lhs.flex.isUndefined() == rhs.flex.isUndefined();
-  if (areNonFloatValuesEqual && !lhs.flex.isUndefined() &&
-      !rhs.flex.isUndefined()) {
-    areNonFloatValuesEqual = areNonFloatValuesEqual && lhs.flex == rhs.flex;
+      lhs.flex().isUndefined() == rhs.flex().isUndefined();
+  if (areNonFloatValuesEqual && !lhs.flex().isUndefined() &&
+      !rhs.flex().isUndefined()) {
+    areNonFloatValuesEqual = areNonFloatValuesEqual && lhs.flex() == rhs.flex();
   }
 
   areNonFloatValuesEqual = areNonFloatValuesEqual &&
-      lhs.flexGrow.isUndefined() == rhs.flexGrow.isUndefined();
-  if (areNonFloatValuesEqual && !lhs.flexGrow.isUndefined()) {
+      lhs.flexGrow().isUndefined() == rhs.flexGrow().isUndefined();
+  if (areNonFloatValuesEqual && !lhs.flexGrow().isUndefined()) {
     areNonFloatValuesEqual =
-        areNonFloatValuesEqual && lhs.flexGrow == rhs.flexGrow;
+        areNonFloatValuesEqual && lhs.flexGrow() == rhs.flexGrow();
   }
 
   areNonFloatValuesEqual = areNonFloatValuesEqual &&
-      lhs.flexShrink.isUndefined() == rhs.flexShrink.isUndefined();
-  if (areNonFloatValuesEqual && !rhs.flexShrink.isUndefined()) {
+      lhs.flexShrink().isUndefined() == rhs.flexShrink().isUndefined();
+  if (areNonFloatValuesEqual && !rhs.flexShrink().isUndefined()) {
     areNonFloatValuesEqual =
-        areNonFloatValuesEqual && lhs.flexShrink == rhs.flexShrink;
+        areNonFloatValuesEqual && lhs.flexShrink() == rhs.flexShrink();
   }
 
-  if (!(lhs.aspectRatio.isUndefined() && rhs.aspectRatio.isUndefined())) {
+  if (!(lhs.aspectRatio().isUndefined() && rhs.aspectRatio().isUndefined())) {
     areNonFloatValuesEqual =
-        areNonFloatValuesEqual && lhs.aspectRatio == rhs.aspectRatio;
+        areNonFloatValuesEqual && lhs.aspectRatio() == rhs.aspectRatio();
   }
 
   return areNonFloatValuesEqual;
diff --git a/modules/lwjgl/yoga/src/main/c/YGStyle.h b/modules/lwjgl/yoga/src/main/c/YGStyle.h
index 7e93502a8..aab7599cc 100644
--- a/modules/lwjgl/yoga/src/main/c/YGStyle.h
+++ b/modules/lwjgl/yoga/src/main/c/YGStyle.h
@@ -1,75 +1,236 @@
-/**
+/*
  * Copyright (c) Facebook, Inc. and its affiliates.
  *
- * This source code is licensed under the MIT license found in the LICENSE
- * file in the root directory of this source tree.
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
  */
+
 #pragma once
+
+#ifdef __cplusplus
+
 #include <algorithm>
 #include <array>
-#include <initializer_list>
+#include <cstdint>
+#include <type_traits>
 #include "CompactValue.h"
 #include "YGEnums.h"
 #include "YGFloatOptional.h"
 #include "Yoga-internal.h"
 #include "Yoga.h"
+#include "BitUtils.h"
 
-#if !defined(ENUM_BITFIELDS_NOT_SUPPORTED)
-#define BITFIELD_ENUM_SIZED(num) : num
-#else
-#define BITFIELD_ENUM_SIZED(num)
-#endif
+class YOGA_EXPORT YGStyle {
+  template <typename Enum>
+  using Values =
+      facebook::yoga::detail::Values<facebook::yoga::enums::count<Enum>()>;
+  using CompactValue = facebook::yoga::detail::CompactValue;
+
+public:
+  using Dimensions = Values<YGDimension>;
+  using Edges = Values<YGEdge>;
+
+  template <typename T>
+  struct BitfieldRef {
+    YGStyle& style;
+    size_t offset;
+    operator T() const {
+      return facebook::yoga::detail::getEnumData<T>(style.flags, offset);
+    }
+    BitfieldRef<T>& operator=(T x) {
+      facebook::yoga::detail::setEnumData<T>(style.flags, offset, x);
+      return *this;
+    }
+  };
+
+  template <typename T, T YGStyle::*Prop>
+  struct Ref {
+    YGStyle& style;
+    operator T() const { return style.*Prop; }
+    Ref<T, Prop>& operator=(T value) {
+      style.*Prop = value;
+      return *this;
+    }
+  };
+
+  template <typename Idx, Values<Idx> YGStyle::*Prop>
+  struct IdxRef {
+    struct Ref {
+      YGStyle& style;
+      Idx idx;
+      operator CompactValue() const { return (style.*Prop)[idx]; }
+      operator YGValue() const { return (style.*Prop)[idx]; }
+      Ref& operator=(CompactValue value) {
+        (style.*Prop)[idx] = value;
+        return *this;
+      }
+    };
+
+    YGStyle& style;
+    IdxRef<Idx, Prop>& operator=(const Values<Idx>& values) {
+      style.*Prop = values;
+      return *this;
+    }
+    operator const Values<Idx>&() const { return style.*Prop; }
+    Ref operator[](Idx idx) { return {style, idx}; }
+    CompactValue operator[](Idx idx) const { return (style.*Prop)[idx]; }
+  };
+
+  YGStyle() {
+    alignContent() = YGAlignFlexStart;
+    alignItems() = YGAlignStretch;
+  }
+  ~YGStyle() = default;
 
-struct YGStyle {
 private:
-  using CompactValue = facebook::yoga::detail::CompactValue;
+  static constexpr size_t directionOffset = 0;
+  static constexpr size_t flexdirectionOffset =
+      directionOffset + facebook::yoga::detail::bitWidthFn<YGDirection>();
+  static constexpr size_t justifyContentOffset = flexdirectionOffset +
+      facebook::yoga::detail::bitWidthFn<YGFlexDirection>();
+  static constexpr size_t alignContentOffset =
+      justifyContentOffset + facebook::yoga::detail::bitWidthFn<YGJustify>();
+  static constexpr size_t alignItemsOffset =
+      alignContentOffset + facebook::yoga::detail::bitWidthFn<YGAlign>();
+  static constexpr size_t alignSelfOffset =
+      alignItemsOffset + facebook::yoga::detail::bitWidthFn<YGAlign>();
+  static constexpr size_t positionTypeOffset =
+      alignSelfOffset + facebook::yoga::detail::bitWidthFn<YGAlign>();
+  static constexpr size_t flexWrapOffset =
+      positionTypeOffset + facebook::yoga::detail::bitWidthFn<YGPositionType>();
+  static constexpr size_t overflowOffset =
+      flexWrapOffset + facebook::yoga::detail::bitWidthFn<YGWrap>();
+  static constexpr size_t displayOffset =
+      overflowOffset + facebook::yoga::detail::bitWidthFn<YGOverflow>();
+
+  uint32_t flags = 0;
+
+  YGFloatOptional flex_ = {};
+  YGFloatOptional flexGrow_ = {};
+  YGFloatOptional flexShrink_ = {};
+  CompactValue flexBasis_ = CompactValue::ofAuto();
+  Edges margin_ = {};
+  Edges position_ = {};
+  Edges padding_ = {};
+  Edges border_ = {};
+  Dimensions dimensions_{CompactValue::ofAuto()};
+  Dimensions minDimensions_ = {};
+  Dimensions maxDimensions_ = {};
+  // Yoga specific properties, not compatible with flexbox specification
+  YGFloatOptional aspectRatio_ = {};
 
 public:
-  using Dimensions = facebook::yoga::detail::Values<2>;
-  using Edges =
-      facebook::yoga::detail::Values<facebook::yoga::enums::count<YGEdge>()>;
-
-  /* Some platforms don't support enum bitfields,
-     so please use BITFIELD_ENUM_SIZED(BITS_COUNT) */
-  YGDirection direction BITFIELD_ENUM_SIZED(2);
-  YGFlexDirection flexDirection BITFIELD_ENUM_SIZED(2);
-  YGJustify justifyContent BITFIELD_ENUM_SIZED(3);
-  YGAlign alignContent BITFIELD_ENUM_SIZED(3);
-  YGAlign alignItems BITFIELD_ENUM_SIZED(3);
-  YGAlign alignSelf BITFIELD_ENUM_SIZED(3);
-  YGPositionType positionType BITFIELD_ENUM_SIZED(1);
-  YGWrap flexWrap BITFIELD_ENUM_SIZED(2);
-  YGOverflow overflow BITFIELD_ENUM_SIZED(2);
-  YGDisplay display BITFIELD_ENUM_SIZED(1);
-  YGFloatOptional flex = {};
-  YGFloatOptional flexGrow = {};
-  YGFloatOptional flexShrink = {};
-  CompactValue flexBasis = CompactValue::ofAuto();
-  Edges margin = {};
-  Edges position = {};
-  Edges padding = {};
-  Edges border = {};
-  Dimensions dimensions{CompactValue::ofAuto()};
-  Dimensions minDimensions = {};
-  Dimensions maxDimensions = {};
+  // for library users needing a type
+  using ValueRepr = std::remove_reference<decltype(margin_[0])>::type;
+
+  YGDirection direction() const {
+    return facebook::yoga::detail::getEnumData<YGDirection>(
+        flags, directionOffset);
+  }
+  BitfieldRef<YGDirection> direction() { return {*this, directionOffset}; }
+
+  YGFlexDirection flexDirection() const {
+    return facebook::yoga::detail::getEnumData<YGFlexDirection>(
+        flags, flexdirectionOffset);
+  }
+  BitfieldRef<YGFlexDirection> flexDirection() {
+    return {*this, flexdirectionOffset};
+  }
+
+  YGJustify justifyContent() const {
+    return facebook::yoga::detail::getEnumData<YGJustify>(
+        flags, justifyContentOffset);
+  }
+  BitfieldRef<YGJustify> justifyContent() {
+    return {*this, justifyContentOffset};
+  }
+
+  YGAlign alignContent() const {
+    return facebook::yoga::detail::getEnumData<YGAlign>(
+        flags, alignContentOffset);
+  }
+  BitfieldRef<YGAlign> alignContent() { return {*this, alignContentOffset}; }
+
+  YGAlign alignItems() const {
+    return facebook::yoga::detail::getEnumData<YGAlign>(
+        flags, alignItemsOffset);
+  }
+  BitfieldRef<YGAlign> alignItems() { return {*this, alignItemsOffset}; }
+
+  YGAlign alignSelf() const {
+    return facebook::yoga::detail::getEnumData<YGAlign>(flags, alignSelfOffset);
+  }
+  BitfieldRef<YGAlign> alignSelf() { return {*this, alignSelfOffset}; }
+
+  YGPositionType positionType() const {
+    return facebook::yoga::detail::getEnumData<YGPositionType>(
+        flags, positionTypeOffset);
+  }
+  BitfieldRef<YGPositionType> positionType() {
+    return {*this, positionTypeOffset};
+  }
+
+  YGWrap flexWrap() const {
+    return facebook::yoga::detail::getEnumData<YGWrap>(flags, flexWrapOffset);
+  }
+  BitfieldRef<YGWrap> flexWrap() { return {*this, flexWrapOffset}; }
+
+  YGOverflow overflow() const {
+    return facebook::yoga::detail::getEnumData<YGOverflow>(
+        flags, overflowOffset);
+  }
+  BitfieldRef<YGOverflow> overflow() { return {*this, overflowOffset}; }
+
+  YGDisplay display() const {
+    return facebook::yoga::detail::getEnumData<YGDisplay>(flags, displayOffset);
+  }
+  BitfieldRef<YGDisplay> display() { return {*this, displayOffset}; }
+
+  YGFloatOptional flex() const { return flex_; }
+  Ref<YGFloatOptional, &YGStyle::flex_> flex() { return {*this}; }
+
+  YGFloatOptional flexGrow() const { return flexGrow_; }
+  Ref<YGFloatOptional, &YGStyle::flexGrow_> flexGrow() { return {*this}; }
+
+  YGFloatOptional flexShrink() const { return flexShrink_; }
+  Ref<YGFloatOptional, &YGStyle::flexShrink_> flexShrink() { return {*this}; }
+
+  CompactValue flexBasis() const { return flexBasis_; }
+  Ref<CompactValue, &YGStyle::flexBasis_> flexBasis() { return {*this}; }
+
+  const Edges& margin() const { return margin_; }
+  IdxRef<YGEdge, &YGStyle::margin_> margin() { return {*this}; }
+
+  const Edges& position() const { return position_; }
+  IdxRef<YGEdge, &YGStyle::position_> position() { return {*this}; }
+
+  const Edges& padding() const { return padding_; }
+  IdxRef<YGEdge, &YGStyle::padding_> padding() { return {*this}; }
+
+  const Edges& border() const { return border_; }
+  IdxRef<YGEdge, &YGStyle::border_> border() { return {*this}; }
+
+  const Dimensions& dimensions() const { return dimensions_; }
+  IdxRef<YGDimension, &YGStyle::dimensions_> dimensions() { return {*this}; }
+
+  const Dimensions& minDimensions() const { return minDimensions_; }
+  IdxRef<YGDimension, &YGStyle::minDimensions_> minDimensions() {
+    return {*this};
+  }
+
+  const Dimensions& maxDimensions() const { return maxDimensions_; }
+  IdxRef<YGDimension, &YGStyle::maxDimensions_> maxDimensions() {
+    return {*this};
+  }
+
   // Yoga specific properties, not compatible with flexbox specification
-  YGFloatOptional aspectRatio = {};
-
-  YGStyle()
-      : direction(YGDirectionInherit),
-        flexDirection(YGFlexDirectionColumn),
-        justifyContent(YGJustifyFlexStart),
-        alignContent(YGAlignFlexStart),
-        alignItems(YGAlignStretch),
-        alignSelf(YGAlignAuto),
-        positionType(YGPositionTypeRelative),
-        flexWrap(YGWrapNoWrap),
-        overflow(YGOverflowVisible),
-        display(YGDisplayFlex) {}
-  ~YGStyle() = default;
+  YGFloatOptional aspectRatio() const { return aspectRatio_; }
+  Ref<YGFloatOptional, &YGStyle::aspectRatio_> aspectRatio() { return {*this}; }
 };
 
-bool operator==(const YGStyle& lhs, const YGStyle& rhs);
-inline bool operator!=(const YGStyle& lhs, const YGStyle& rhs) {
+YOGA_EXPORT bool operator==(const YGStyle& lhs, const YGStyle& rhs);
+YOGA_EXPORT inline bool operator!=(const YGStyle& lhs, const YGStyle& rhs) {
   return !(lhs == rhs);
 }
+
+#endif
diff --git a/modules/lwjgl/yoga/src/main/c/YGValue.cpp b/modules/lwjgl/yoga/src/main/c/YGValue.cpp
index fcdd0c693..37383a555 100644
--- a/modules/lwjgl/yoga/src/main/c/YGValue.cpp
+++ b/modules/lwjgl/yoga/src/main/c/YGValue.cpp
@@ -1,9 +1,10 @@
-/**
+/*
  * Copyright (c) Facebook, Inc. and its affiliates.
  *
- * This source code is licensed under the MIT license found in the LICENSE
- * file in the root directory of this source tree.
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
  */
+
 #include "YGValue.h"
 
 const YGValue YGValueZero = {0, YGUnitPoint};
diff --git a/modules/lwjgl/yoga/src/main/c/YGValue.h b/modules/lwjgl/yoga/src/main/c/YGValue.h
index 170047ea5..a20009784 100644
--- a/modules/lwjgl/yoga/src/main/c/YGValue.h
+++ b/modules/lwjgl/yoga/src/main/c/YGValue.h
@@ -1,15 +1,23 @@
-/**
+/*
  * Copyright (c) Facebook, Inc. and its affiliates.
  *
- * This source code is licensed under the MIT license found in the LICENSE
- * file in the root directory of this source tree.
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
  */
+
 #pragma once
 
 #include <math.h>
 #include "YGEnums.h"
 #include "YGMacros.h"
 
+#if defined(_MSC_VER) && defined(__clang__)
+#define COMPILING_WITH_CLANG_ON_WINDOWS
+#endif
+#if defined(COMPILING_WITH_CLANG_ON_WINDOWS)
+#include <limits>
+constexpr float YGUndefined = std::numeric_limits<float>::quiet_NaN();
+#else
 YG_EXTERN_C_BEGIN
 
 // Not defined in MSVC++
@@ -19,17 +27,21 @@ static const uint32_t __nan = 0x7fc00000;
 #endif
 
 #define YGUndefined NAN
+#endif
 
 typedef struct YGValue {
   float value;
   YGUnit unit;
 } YGValue;
 
-extern const YGValue YGValueAuto;
-extern const YGValue YGValueUndefined;
-extern const YGValue YGValueZero;
+YOGA_EXPORT extern const YGValue YGValueAuto;
+YOGA_EXPORT extern const YGValue YGValueUndefined;
+YOGA_EXPORT extern const YGValue YGValueZero;
 
+#if !defined(COMPILING_WITH_CLANG_ON_WINDOWS)
 YG_EXTERN_C_END
+#endif
+#undef COMPILING_WITH_CLANG_ON_WINDOWS
 
 #ifdef __cplusplus
 
diff --git a/modules/lwjgl/yoga/src/main/c/Yoga-internal.h b/modules/lwjgl/yoga/src/main/c/Yoga-internal.h
index be815921e..acd173be8 100644
--- a/modules/lwjgl/yoga/src/main/c/Yoga-internal.h
+++ b/modules/lwjgl/yoga/src/main/c/Yoga-internal.h
@@ -1,9 +1,10 @@
-/**
+/*
  * Copyright (c) Facebook, Inc. and its affiliates.
  *
- * This source code is licensed under the MIT license found in the LICENSE
- * file in the root directory of this source tree.
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
  */
+
 #pragma once
 #include <algorithm>
 #include <array>
@@ -16,12 +17,6 @@ using YGVector = std::vector<YGNodeRef>;
 
 YG_EXTERN_C_BEGIN
 
-WIN_EXPORT float YGRoundValueToPixelGrid(
-    const float value,
-    const float pointScaleFactor,
-    const bool forceCeil,
-    const bool forceFloor);
-
 void YGNodeCalculateLayoutWithContext(
     YGNodeRef node,
     float availableWidth,
@@ -29,8 +24,6 @@ void YGNodeCalculateLayoutWithContext(
     YGDirection ownerDirection,
     void* layoutContext);
 
-void YGSetUsedCachedEntries(size_t);
-
 YG_EXTERN_C_END
 
 namespace facebook {
@@ -40,6 +33,10 @@ inline bool isUndefined(float value) {
   return std::isnan(value);
 }
 
+inline bool isUndefined(double value) {
+  return std::isnan(value);
+}
+
 } // namespace yoga
 } // namespace facebook
 
@@ -61,10 +58,10 @@ struct YGCachedMeasurement {
   float computedHeight;
 
   YGCachedMeasurement()
-      : availableWidth(0),
-        availableHeight(0),
-        widthMeasureMode((YGMeasureMode) -1),
-        heightMeasureMode((YGMeasureMode) -1),
+      : availableWidth(-1),
+        availableHeight(-1),
+        widthMeasureMode(YGMeasureModeUndefined),
+        heightMeasureMode(YGMeasureModeUndefined),
         computedWidth(-1),
         computedHeight(-1) {}
 
@@ -93,9 +90,9 @@ struct YGCachedMeasurement {
   }
 };
 
-// This value was chosen based on empiracle data. Even the most complicated
-// layouts should not require more than 16 entries to fit within the cache.
-#define YG_MAX_CACHED_RESULT_COUNT 16
+// This value was chosen based on empirical data:
+// 98% of analyzed layouts require less than 8 entries.
+#define YG_MAX_CACHED_RESULT_COUNT 8
 
 namespace facebook {
 namespace yoga {
@@ -112,12 +109,8 @@ public:
     values_.fill(defaultValue);
   }
 
-  const CompactValue& operator[](size_t i) const noexcept {
-    return values_[i];
-  }
-  CompactValue& operator[](size_t i) noexcept {
-    return values_[i];
-  }
+  const CompactValue& operator[](size_t i) const noexcept { return values_[i]; }
+  CompactValue& operator[](size_t i) noexcept { return values_[i]; }
 
   template <size_t I>
   YGValue get() const noexcept {
@@ -155,8 +148,3 @@ static const float kDefaultFlexShrink = 0.0f;
 static const float kWebDefaultFlexShrink = 1.0f;
 
 extern bool YGFloatsEqual(const float a, const float b);
-extern facebook::yoga::detail::CompactValue YGComputedEdgeValue(
-    const facebook::yoga::detail::Values<
-        facebook::yoga::enums::count<YGEdge>()>& edges,
-    YGEdge edge,
-    facebook::yoga::detail::CompactValue defaultValue);
diff --git a/modules/lwjgl/yoga/src/main/c/Yoga.cpp b/modules/lwjgl/yoga/src/main/c/Yoga.cpp
index 1e3d79103..24abd76db 100644
--- a/modules/lwjgl/yoga/src/main/c/Yoga.cpp
+++ b/modules/lwjgl/yoga/src/main/c/Yoga.cpp
@@ -1,19 +1,22 @@
-/**
+/*
  * Copyright (c) Facebook, Inc. and its affiliates.
  *
- * This source code is licensed under the MIT license found in the LICENSE
- * file in the root directory of this source tree.
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
  */
+
 #include "Yoga.h"
 #include "log.h"
 #include <float.h>
 #include <string.h>
 #include <algorithm>
+#include <atomic>
+#include <memory>
 #include "Utils.h"
 #include "YGNode.h"
 #include "YGNodePrint.h"
 #include "Yoga-internal.h"
-#include "instrumentation.h"
+#include "event/event.h"
 #ifdef _MSC_VER
 #include <float.h>
 
@@ -28,15 +31,6 @@ __forceinline const float fmaxf(const float a, const float b) {
 using namespace facebook::yoga;
 using detail::Log;
 
-namespace {
-size_t usedMeasureCacheEntries = YG_MAX_CACHED_RESULT_COUNT;
-}
-
-void YGSetUsedCachedEntries(size_t n) {
-  usedMeasureCacheEntries =
-      n == 0 || n > YG_MAX_CACHED_RESULT_COUNT ? YG_MAX_CACHED_RESULT_COUNT : n;
-}
-
 #ifdef ANDROID
 static int YGAndroidLog(
     const YGConfigRef config,
@@ -112,141 +106,116 @@ static int YGDefaultLog(
 #undef YG_UNUSED
 #endif
 
-bool YGFloatIsUndefined(const float value) {
+static inline bool YGDoubleIsUndefined(const double value) {
   return facebook::yoga::isUndefined(value);
 }
 
-detail::CompactValue YGComputedEdgeValue(
-    const YGStyle::Edges& edges,
-    YGEdge edge,
-    detail::CompactValue defaultValue) {
-  if (!edges[edge].isUndefined()) {
-    return edges[edge];
-  }
-
-  if ((edge == YGEdgeTop || edge == YGEdgeBottom) &&
-      !edges[YGEdgeVertical].isUndefined()) {
-    return edges[YGEdgeVertical];
-  }
-
-  if ((edge == YGEdgeLeft || edge == YGEdgeRight || edge == YGEdgeStart ||
-       edge == YGEdgeEnd) &&
-      !edges[YGEdgeHorizontal].isUndefined()) {
-    return edges[YGEdgeHorizontal];
-  }
-
-  if (!edges[YGEdgeAll].isUndefined()) {
-    return edges[YGEdgeAll];
-  }
-
-  if (edge == YGEdgeStart || edge == YGEdgeEnd) {
-    return detail::CompactValue::ofUndefined();
-  }
-
-  return defaultValue;
+YOGA_EXPORT bool YGFloatIsUndefined(const float value) {
+  return facebook::yoga::isUndefined(value);
 }
 
-void* YGNodeGetContext(YGNodeRef node) {
+YOGA_EXPORT void* YGNodeGetContext(YGNodeRef node) {
   return node->getContext();
 }
 
-void YGNodeSetContext(YGNodeRef node, void* context) {
+YOGA_EXPORT void YGNodeSetContext(YGNodeRef node, void* context) {
   return node->setContext(context);
 }
 
-bool YGNodeHasMeasureFunc(YGNodeRef node) {
+YOGA_EXPORT bool YGNodeHasMeasureFunc(YGNodeRef node) {
   return node->hasMeasureFunc();
 }
 
-void YGNodeSetMeasureFunc(YGNodeRef node, YGMeasureFunc measureFunc) {
+YOGA_EXPORT void YGNodeSetMeasureFunc(
+    YGNodeRef node,
+    YGMeasureFunc measureFunc) {
   node->setMeasureFunc(measureFunc);
 }
 
-bool YGNodeHasBaselineFunc(YGNodeRef node) {
+YOGA_EXPORT bool YGNodeHasBaselineFunc(YGNodeRef node) {
   return node->hasBaselineFunc();
 }
 
-void YGNodeSetBaselineFunc(YGNodeRef node, YGBaselineFunc baselineFunc) {
+YOGA_EXPORT void YGNodeSetBaselineFunc(
+    YGNodeRef node,
+    YGBaselineFunc baselineFunc) {
   node->setBaselineFunc(baselineFunc);
 }
 
-YGDirtiedFunc YGNodeGetDirtiedFunc(YGNodeRef node) {
+YOGA_EXPORT YGDirtiedFunc YGNodeGetDirtiedFunc(YGNodeRef node) {
   return node->getDirtied();
 }
 
-void YGNodeSetDirtiedFunc(YGNodeRef node, YGDirtiedFunc dirtiedFunc) {
+YOGA_EXPORT void YGNodeSetDirtiedFunc(
+    YGNodeRef node,
+    YGDirtiedFunc dirtiedFunc) {
   node->setDirtiedFunc(dirtiedFunc);
 }
 
-void YGNodeSetPrintFunc(YGNodeRef node, YGPrintFunc printFunc) {
+YOGA_EXPORT void YGNodeSetPrintFunc(YGNodeRef node, YGPrintFunc printFunc) {
   node->setPrintFunc(printFunc);
 }
 
-bool YGNodeGetHasNewLayout(YGNodeRef node) {
+YOGA_EXPORT bool YGNodeGetHasNewLayout(YGNodeRef node) {
   return node->getHasNewLayout();
 }
 
-void YGConfigSetPrintTreeFlag(YGConfigRef config, bool enabled) {
+YOGA_EXPORT void YGConfigSetPrintTreeFlag(YGConfigRef config, bool enabled) {
   config->printTree = enabled;
 }
 
-void YGNodeSetHasNewLayout(YGNodeRef node, bool hasNewLayout) {
+YOGA_EXPORT void YGNodeSetHasNewLayout(YGNodeRef node, bool hasNewLayout) {
   node->setHasNewLayout(hasNewLayout);
 }
 
-YGNodeType YGNodeGetNodeType(YGNodeRef node) {
+YOGA_EXPORT YGNodeType YGNodeGetNodeType(YGNodeRef node) {
   return node->getNodeType();
 }
 
-void YGNodeSetNodeType(YGNodeRef node, YGNodeType nodeType) {
+YOGA_EXPORT void YGNodeSetNodeType(YGNodeRef node, YGNodeType nodeType) {
   return node->setNodeType(nodeType);
 }
 
-bool YGNodeIsDirty(YGNodeRef node) {
+YOGA_EXPORT bool YGNodeIsDirty(YGNodeRef node) {
   return node->isDirty();
 }
 
-bool YGNodeLayoutGetDidUseLegacyFlag(const YGNodeRef node) {
+YOGA_EXPORT bool YGNodeLayoutGetDidUseLegacyFlag(const YGNodeRef node) {
   return node->didUseLegacyFlag();
 }
 
-void YGNodeMarkDirtyAndPropogateToDescendants(const YGNodeRef node) {
+YOGA_EXPORT void YGNodeMarkDirtyAndPropogateToDescendants(
+    const YGNodeRef node) {
   return node->markDirtyAndPropogateDownwards();
 }
 
-int32_t gNodeInstanceCount = 0;
 int32_t gConfigInstanceCount = 0;
 
-WIN_EXPORT YGNodeRef YGNodeNewWithConfig(const YGConfigRef config) {
-  const YGNodeRef node = new YGNode();
+YOGA_EXPORT WIN_EXPORT YGNodeRef YGNodeNewWithConfig(const YGConfigRef config) {
+  const YGNodeRef node = new YGNode{config};
   YGAssertWithConfig(
       config, node != nullptr, "Could not allocate memory for node");
-  gNodeInstanceCount++;
+  Event::publish<Event::NodeAllocation>(node, {config});
 
-  if (config->useWebDefaults) {
-    node->setStyleFlexDirection(YGFlexDirectionRow);
-    node->setStyleAlignContent(YGAlignStretch);
-  }
-  node->setConfig(config);
   return node;
 }
 
-YGConfigRef YGConfigGetDefault() {
+YOGA_EXPORT YGConfigRef YGConfigGetDefault() {
   static YGConfigRef defaultConfig = YGConfigNew();
   return defaultConfig;
 }
 
-YGNodeRef YGNodeNew(void) {
+YOGA_EXPORT YGNodeRef YGNodeNew(void) {
   return YGNodeNewWithConfig(YGConfigGetDefault());
 }
 
-YGNodeRef YGNodeClone(YGNodeRef oldNode) {
+YOGA_EXPORT YGNodeRef YGNodeClone(YGNodeRef oldNode) {
   YGNodeRef node = new YGNode(*oldNode);
   YGAssertWithConfig(
       oldNode->getConfig(),
       node != nullptr,
       "Could not allocate memory for node");
-  gNodeInstanceCount++;
+  Event::publish<Event::NodeAllocation>(node, {node->getConfig()});
   node->setOwner(nullptr);
   return node;
 }
@@ -254,15 +223,16 @@ YGNodeRef YGNodeClone(YGNodeRef oldNode) {
 static YGConfigRef YGConfigClone(const YGConfig& oldConfig) {
   const YGConfigRef config = new YGConfig(oldConfig);
   YGAssert(config != nullptr, "Could not allocate memory for config");
-  if (config == nullptr) {
-    abort();
-  }
   gConfigInstanceCount++;
   return config;
 }
 
 static YGNodeRef YGNodeDeepClone(YGNodeRef oldNode) {
-  YGNodeRef node = YGNodeClone(oldNode);
+  auto config = YGConfigClone(*oldNode->getConfig());
+  auto node = new YGNode{*oldNode, config};
+  node->setOwner(nullptr);
+  Event::publish<Event::NodeAllocation>(node, {node->getConfig()});
+
   YGVector vec = YGVector();
   vec.reserve(oldNode->getChildren().size());
   YGNodeRef childNode = nullptr;
@@ -273,14 +243,10 @@ static YGNodeRef YGNodeDeepClone(YGNodeRef oldNode) {
   }
   node->setChildren(vec);
 
-  if (oldNode->getConfig() != nullptr) {
-    node->setConfig(YGConfigClone(*(oldNode->getConfig())));
-  }
-
   return node;
 }
 
-void YGNodeFree(const YGNodeRef node) {
+YOGA_EXPORT void YGNodeFree(const YGNodeRef node) {
   if (YGNodeRef owner = node->getOwner()) {
     owner->removeChild(node);
     node->setOwner(nullptr);
@@ -293,8 +259,8 @@ void YGNodeFree(const YGNodeRef node) {
   }
 
   node->clearChildren();
+  Event::publish<Event::NodeDeallocation>(node, {node->getConfig()});
   delete node;
-  gNodeInstanceCount--;
 }
 
 static void YGConfigFreeRecursive(const YGNodeRef root) {
@@ -308,7 +274,7 @@ static void YGConfigFreeRecursive(const YGNodeRef root) {
   }
 }
 
-void YGNodeFreeRecursiveWithCleanupFunc(
+YOGA_EXPORT void YGNodeFreeRecursiveWithCleanupFunc(
     const YGNodeRef root,
     YGNodeCleanupFunc cleanup) {
   uint32_t skipped = 0;
@@ -328,23 +294,19 @@ void YGNodeFreeRecursiveWithCleanupFunc(
   YGNodeFree(root);
 }
 
-void YGNodeFreeRecursive(const YGNodeRef root) {
+YOGA_EXPORT void YGNodeFreeRecursive(const YGNodeRef root) {
   return YGNodeFreeRecursiveWithCleanupFunc(root, nullptr);
 }
 
-void YGNodeReset(YGNodeRef node) {
+YOGA_EXPORT void YGNodeReset(YGNodeRef node) {
   node->reset();
 }
 
-int32_t YGNodeGetInstanceCount(void) {
-  return gNodeInstanceCount;
-}
-
 int32_t YGConfigGetInstanceCount(void) {
   return gConfigInstanceCount;
 }
 
-YGConfigRef YGConfigNew(void) {
+YOGA_EXPORT YGConfigRef YGConfigNew(void) {
 #ifdef ANDROID
   const YGConfigRef config = new YGConfig(YGAndroidLog);
 #else
@@ -354,7 +316,7 @@ YGConfigRef YGConfigNew(void) {
   return config;
 }
 
-void YGConfigFree(const YGConfigRef config) {
+YOGA_EXPORT void YGConfigFree(const YGConfigRef config) {
   delete config;
   gConfigInstanceCount--;
 }
@@ -363,18 +325,20 @@ void YGConfigCopy(const YGConfigRef dest, const YGConfigRef src) {
   memcpy(dest, src, sizeof(YGConfig));
 }
 
-void YGNodeSetIsReferenceBaseline(YGNodeRef node, bool isReferenceBaseline) {
+YOGA_EXPORT void YGNodeSetIsReferenceBaseline(
+    YGNodeRef node,
+    bool isReferenceBaseline) {
   if (node->isReferenceBaseline() != isReferenceBaseline) {
     node->setIsReferenceBaseline(isReferenceBaseline);
     node->markDirtyAndPropogate();
   }
 }
 
-bool YGNodeIsReferenceBaseline(YGNodeRef node) {
+YOGA_EXPORT bool YGNodeIsReferenceBaseline(YGNodeRef node) {
   return node->isReferenceBaseline();
 }
 
-void YGNodeInsertChild(
+YOGA_EXPORT void YGNodeInsertChild(
     const YGNodeRef owner,
     const YGNodeRef child,
     const uint32_t index) {
@@ -393,7 +357,17 @@ void YGNodeInsertChild(
   owner->markDirtyAndPropogate();
 }
 
-void YGNodeRemoveChild(const YGNodeRef owner, const YGNodeRef excludedChild) {
+YOGA_EXPORT void YGNodeSwapChild(
+    const YGNodeRef owner,
+    const YGNodeRef child,
+    const uint32_t index) {
+  owner->replaceChild(child, index);
+  child->setOwner(owner);
+}
+
+YOGA_EXPORT void YGNodeRemoveChild(
+    const YGNodeRef owner,
+    const YGNodeRef excludedChild) {
   if (YGNodeGetChildCount(owner) == 0) {
     // This is an empty set. Nothing to remove.
     return;
@@ -412,7 +386,7 @@ void YGNodeRemoveChild(const YGNodeRef owner, const YGNodeRef excludedChild) {
   }
 }
 
-void YGNodeRemoveAllChildren(const YGNodeRef owner) {
+YOGA_EXPORT void YGNodeRemoveAllChildren(const YGNodeRef owner) {
   const uint32_t childCount = YGNodeGetChildCount(owner);
   if (childCount == 0) {
     // This is an empty set already. Nothing to do.
@@ -472,40 +446,41 @@ static void YGNodeSetChildrenInternal(
   }
 }
 
-void YGNodeSetChildren(
-    YGNodeRef const owner,
+YOGA_EXPORT void YGNodeSetChildren(
+    const YGNodeRef owner,
     const YGNodeRef c[],
     const uint32_t count) {
   const YGVector children = {c, c + count};
   YGNodeSetChildrenInternal(owner, children);
 }
 
-void YGNodeSetChildren(
+YOGA_EXPORT void YGNodeSetChildren(
     YGNodeRef const owner,
     const std::vector<YGNodeRef>& children) {
   YGNodeSetChildrenInternal(owner, children);
 }
 
-YGNodeRef YGNodeGetChild(const YGNodeRef node, const uint32_t index) {
+YOGA_EXPORT YGNodeRef
+YGNodeGetChild(const YGNodeRef node, const uint32_t index) {
   if (index < node->getChildren().size()) {
     return node->getChild(index);
   }
   return nullptr;
 }
 
-uint32_t YGNodeGetChildCount(const YGNodeRef node) {
+YOGA_EXPORT uint32_t YGNodeGetChildCount(const YGNodeRef node) {
   return static_cast<uint32_t>(node->getChildren().size());
 }
 
-YGNodeRef YGNodeGetOwner(const YGNodeRef node) {
+YOGA_EXPORT YGNodeRef YGNodeGetOwner(const YGNodeRef node) {
   return node->getOwner();
 }
 
-YGNodeRef YGNodeGetParent(const YGNodeRef node) {
+YOGA_EXPORT YGNodeRef YGNodeGetParent(const YGNodeRef node) {
   return node->getOwner();
 }
 
-void YGNodeMarkDirty(const YGNodeRef node) {
+YOGA_EXPORT void YGNodeMarkDirty(const YGNodeRef node) {
   YGAssertWithNode(
       node,
       node->hasMeasureFunc(),
@@ -515,296 +490,200 @@ void YGNodeMarkDirty(const YGNodeRef node) {
   node->markDirtyAndPropogate();
 }
 
-void YGNodeCopyStyle(const YGNodeRef dstNode, const YGNodeRef srcNode) {
+YOGA_EXPORT void YGNodeCopyStyle(
+    const YGNodeRef dstNode,
+    const YGNodeRef srcNode) {
   if (!(dstNode->getStyle() == srcNode->getStyle())) {
     dstNode->setStyle(srcNode->getStyle());
     dstNode->markDirtyAndPropogate();
   }
 }
 
-float YGNodeStyleGetFlexGrow(const YGNodeRef node) {
-  return node->getStyle().flexGrow.isUndefined()
+YOGA_EXPORT float YGNodeStyleGetFlexGrow(const YGNodeConstRef node) {
+  return node->getStyle().flexGrow().isUndefined()
       ? kDefaultFlexGrow
-      : node->getStyle().flexGrow.unwrap();
+      : node->getStyle().flexGrow().unwrap();
 }
 
-float YGNodeStyleGetFlexShrink(const YGNodeRef node) {
-  return node->getStyle().flexShrink.isUndefined()
+YOGA_EXPORT float YGNodeStyleGetFlexShrink(const YGNodeConstRef node) {
+  return node->getStyle().flexShrink().isUndefined()
       ? (node->getConfig()->useWebDefaults ? kWebDefaultFlexShrink
                                            : kDefaultFlexShrink)
-      : node->getStyle().flexShrink.unwrap();
+      : node->getStyle().flexShrink().unwrap();
 }
 
 namespace {
 
-struct Value {
-  template <YGUnit U>
-  static detail::CompactValue create(float value) {
-    return detail::CompactValue::ofMaybe<U>(value);
+template <typename T, typename NeedsUpdate, typename Update>
+void updateStyle(
+    YGNode* node,
+    T value,
+    NeedsUpdate&& needsUpdate,
+    Update&& update) {
+  if (needsUpdate(node->getStyle(), value)) {
+    update(node->getStyle(), value);
+    node->markDirtyAndPropogate();
   }
-};
-
-template <>
-inline detail::CompactValue Value::create<YGUnitUndefined>(float) {
-  return detail::CompactValue::ofUndefined();
 }
 
-template <>
-inline detail::CompactValue Value::create<YGUnitAuto>(float) {
-  return detail::CompactValue::ofAuto();
+template <typename Ref, typename T>
+void updateStyle(YGNode* node, Ref (YGStyle::*prop)(), T value) {
+  updateStyle(
+      node,
+      value,
+      [prop](YGStyle& s, T x) { return (s.*prop)() != x; },
+      [prop](YGStyle& s, T x) { (s.*prop)() = x; });
+}
+
+template <typename Ref, typename Idx>
+void updateIndexedStyleProp(
+    YGNode* node,
+    Ref (YGStyle::*prop)(),
+    Idx idx,
+    detail::CompactValue value) {
+  using detail::CompactValue;
+  updateStyle(
+      node,
+      value,
+      [idx, prop](YGStyle& s, CompactValue x) { return (s.*prop)()[idx] != x; },
+      [idx, prop](YGStyle& s, CompactValue x) { (s.*prop)()[idx] = x; });
 }
 
-template <YGStyle::Dimensions YGStyle::*P>
-struct DimensionProp {
-  template <YGDimension idx>
-  static YGValue get(YGNodeRef node) {
-    YGValue value = (node->getStyle().*P)[idx];
-    if (value.unit == YGUnitUndefined || value.unit == YGUnitAuto) {
-      value.value = YGUndefined;
-    }
-    return value;
-  }
-
-  template <YGDimension idx, YGUnit U>
-  static void set(YGNodeRef node, float newValue) {
-    auto value = Value::create<U>(newValue);
-    if ((node->getStyle().*P)[idx] != value) {
-      (node->getStyle().*P)[idx] = value;
-      node->markDirtyAndPropogate();
-    }
-  }
-};
-
 } // namespace
 
-#define YG_NODE_STYLE_PROPERTY_SETTER_UNIT_AUTO_IMPL(                      \
-    type, name, paramName, instanceName)                                   \
-  void YGNodeStyleSet##name(const YGNodeRef node, const type paramName) {  \
-    auto value = detail::CompactValue::ofMaybe<YGUnitPoint>(paramName);    \
-    if (node->getStyle().instanceName != value) {                          \
-      node->getStyle().instanceName = value;                               \
-      node->markDirtyAndPropogate();                                       \
-    }                                                                      \
-  }                                                                        \
-                                                                           \
-  void YGNodeStyleSet##name##Percent(                                      \
-      const YGNodeRef node, const type paramName) {                        \
-    auto value = detail::CompactValue::ofMaybe<YGUnitPercent>(paramName);  \
-    if (node->getStyle().instanceName != value) {                          \
-      node->getStyle().instanceName = value;                               \
-      node->markDirtyAndPropogate();                                       \
-    }                                                                      \
-  }                                                                        \
-                                                                           \
-  void YGNodeStyleSet##name##Auto(const YGNodeRef node) {                  \
-    if (node->getStyle().instanceName != detail::CompactValue::ofAuto()) { \
-      node->getStyle().instanceName = detail::CompactValue::ofAuto();      \
-      node->markDirtyAndPropogate();                                       \
-    }                                                                      \
-  }
-
-#define YG_NODE_STYLE_PROPERTY_UNIT_AUTO_IMPL(                       \
-    type, name, paramName, instanceName)                             \
-  YG_NODE_STYLE_PROPERTY_SETTER_UNIT_AUTO_IMPL(                      \
-      float, name, paramName, instanceName)                          \
-                                                                     \
-  type YGNodeStyleGet##name(const YGNodeRef node) {                  \
-    YGValue value = node->getStyle().instanceName;                   \
-    if (value.unit == YGUnitUndefined || value.unit == YGUnitAuto) { \
-      value.value = YGUndefined;                                     \
-    }                                                                \
-    return value;                                                    \
-  }
-
-#define YG_NODE_STYLE_EDGE_PROPERTY_UNIT_AUTO_IMPL(type, name, instanceName) \
-  void YGNodeStyleSet##name##Auto(const YGNodeRef node, const YGEdge edge) { \
-    if (node->getStyle().instanceName[edge] !=                               \
-        detail::CompactValue::ofAuto()) {                                    \
-      node->getStyle().instanceName[edge] = detail::CompactValue::ofAuto();  \
-      node->markDirtyAndPropogate();                                         \
-    }                                                                        \
-  }
-
-#define YG_NODE_STYLE_EDGE_PROPERTY_UNIT_IMPL(                            \
-    type, name, paramName, instanceName)                                  \
-  void YGNodeStyleSet##name(                                              \
-      const YGNodeRef node, const YGEdge edge, const float paramName) {   \
-    auto value = detail::CompactValue::ofMaybe<YGUnitPoint>(paramName);   \
-    if (node->getStyle().instanceName[edge] != value) {                   \
-      node->getStyle().instanceName[edge] = value;                        \
-      node->markDirtyAndPropogate();                                      \
-    }                                                                     \
-  }                                                                       \
-                                                                          \
-  void YGNodeStyleSet##name##Percent(                                     \
-      const YGNodeRef node, const YGEdge edge, const float paramName) {   \
-    auto value = detail::CompactValue::ofMaybe<YGUnitPercent>(paramName); \
-    if (node->getStyle().instanceName[edge] != value) {                   \
-      node->getStyle().instanceName[edge] = value;                        \
-      node->markDirtyAndPropogate();                                      \
-    }                                                                     \
-  }                                                                       \
-                                                                          \
-  type YGNodeStyleGet##name(const YGNodeRef node, const YGEdge edge) {    \
-    YGValue value = node->getStyle().instanceName[edge];                  \
-    if (value.unit == YGUnitUndefined || value.unit == YGUnitAuto) {      \
-      value.value = YGUndefined;                                          \
-    }                                                                     \
-    return value;                                                         \
-  }
-
-#define YG_NODE_LAYOUT_PROPERTY_IMPL(type, name, instanceName) \
-  type YGNodeLayoutGet##name(const YGNodeRef node) {           \
-    return node->getLayout().instanceName;                     \
-  }
-
-#define YG_NODE_LAYOUT_RESOLVED_PROPERTY_IMPL(type, name, instanceName) \
-  type YGNodeLayoutGet##name(const YGNodeRef node, const YGEdge edge) { \
-    YGAssertWithNode(                                                   \
-        node,                                                           \
-        edge <= YGEdgeEnd,                                              \
-        "Cannot get layout properties of multi-edge shorthands");       \
-                                                                        \
-    if (edge == YGEdgeLeft) {                                           \
-      if (node->getLayout().direction == YGDirectionRTL) {              \
-        return node->getLayout().instanceName[YGEdgeEnd];               \
-      } else {                                                          \
-        return node->getLayout().instanceName[YGEdgeStart];             \
-      }                                                                 \
-    }                                                                   \
-                                                                        \
-    if (edge == YGEdgeRight) {                                          \
-      if (node->getLayout().direction == YGDirectionRTL) {              \
-        return node->getLayout().instanceName[YGEdgeStart];             \
-      } else {                                                          \
-        return node->getLayout().instanceName[YGEdgeEnd];               \
-      }                                                                 \
-    }                                                                   \
-                                                                        \
-    return node->getLayout().instanceName[edge];                        \
-  }
-
-#define YG_NODE_STYLE_SET(node, property, value) \
-  if (node->getStyle().property != value) {      \
-    node->getStyle().property = value;           \
-    node->markDirtyAndPropogate();               \
-  }
+// MSVC has trouble inferring the return type of pointer to member functions
+// with const and non-const overloads, instead of preferring the non-const
+// overload like clang and GCC. For the purposes of updateStyle(), we can help
+// MSVC by specifying that return type explicitely. In combination with
+// decltype, MSVC will prefer the non-const version.
+#define MSVC_HINT(PROP) decltype(YGStyle{}.PROP())
 
-void YGNodeStyleSetDirection(const YGNodeRef node, const YGDirection value) {
-  YG_NODE_STYLE_SET(node, direction, value);
+YOGA_EXPORT void YGNodeStyleSetDirection(
+    const YGNodeRef node,
+    const YGDirection value) {
+  updateStyle<MSVC_HINT(direction)>(node, &YGStyle::direction, value);
 }
-YGDirection YGNodeStyleGetDirection(const YGNodeRef node) {
-  return node->getStyle().direction;
+YOGA_EXPORT YGDirection YGNodeStyleGetDirection(const YGNodeConstRef node) {
+  return node->getStyle().direction();
 }
 
-void YGNodeStyleSetFlexDirection(
+YOGA_EXPORT void YGNodeStyleSetFlexDirection(
     const YGNodeRef node,
     const YGFlexDirection flexDirection) {
-  YG_NODE_STYLE_SET(node, flexDirection, flexDirection);
+  updateStyle<MSVC_HINT(flexDirection)>(
+      node, &YGStyle::flexDirection, flexDirection);
 }
-YGFlexDirection YGNodeStyleGetFlexDirection(const YGNodeRef node) {
-  return node->getStyle().flexDirection;
+YOGA_EXPORT YGFlexDirection
+YGNodeStyleGetFlexDirection(const YGNodeConstRef node) {
+  return node->getStyle().flexDirection();
 }
 
-void YGNodeStyleSetJustifyContent(
+YOGA_EXPORT void YGNodeStyleSetJustifyContent(
     const YGNodeRef node,
     const YGJustify justifyContent) {
-  YG_NODE_STYLE_SET(node, justifyContent, justifyContent);
+  updateStyle<MSVC_HINT(justifyContent)>(
+      node, &YGStyle::justifyContent, justifyContent);
 }
-YGJustify YGNodeStyleGetJustifyContent(const YGNodeRef node) {
-  return node->getStyle().justifyContent;
+YOGA_EXPORT YGJustify YGNodeStyleGetJustifyContent(const YGNodeConstRef node) {
+  return node->getStyle().justifyContent();
 }
 
-void YGNodeStyleSetAlignContent(
+YOGA_EXPORT void YGNodeStyleSetAlignContent(
     const YGNodeRef node,
     const YGAlign alignContent) {
-  YG_NODE_STYLE_SET(node, alignContent, alignContent);
+  updateStyle<MSVC_HINT(alignContent)>(
+      node, &YGStyle::alignContent, alignContent);
 }
-YGAlign YGNodeStyleGetAlignContent(const YGNodeRef node) {
-  return node->getStyle().alignContent;
+YOGA_EXPORT YGAlign YGNodeStyleGetAlignContent(const YGNodeConstRef node) {
+  return node->getStyle().alignContent();
 }
 
-void YGNodeStyleSetAlignItems(const YGNodeRef node, const YGAlign alignItems) {
-  YG_NODE_STYLE_SET(node, alignItems, alignItems);
+YOGA_EXPORT void YGNodeStyleSetAlignItems(
+    const YGNodeRef node,
+    const YGAlign alignItems) {
+  updateStyle<MSVC_HINT(alignItems)>(node, &YGStyle::alignItems, alignItems);
 }
-YGAlign YGNodeStyleGetAlignItems(const YGNodeRef node) {
-  return node->getStyle().alignItems;
+YOGA_EXPORT YGAlign YGNodeStyleGetAlignItems(const YGNodeConstRef node) {
+  return node->getStyle().alignItems();
 }
 
-void YGNodeStyleSetAlignSelf(const YGNodeRef node, const YGAlign alignSelf) {
-  YG_NODE_STYLE_SET(node, alignSelf, alignSelf);
+YOGA_EXPORT void YGNodeStyleSetAlignSelf(
+    const YGNodeRef node,
+    const YGAlign alignSelf) {
+  updateStyle<MSVC_HINT(alignSelf)>(node, &YGStyle::alignSelf, alignSelf);
 }
-YGAlign YGNodeStyleGetAlignSelf(const YGNodeRef node) {
-  return node->getStyle().alignSelf;
+YOGA_EXPORT YGAlign YGNodeStyleGetAlignSelf(const YGNodeConstRef node) {
+  return node->getStyle().alignSelf();
 }
 
-void YGNodeStyleSetPositionType(
+YOGA_EXPORT void YGNodeStyleSetPositionType(
     const YGNodeRef node,
     const YGPositionType positionType) {
-  YG_NODE_STYLE_SET(node, positionType, positionType);
+  updateStyle<MSVC_HINT(positionType)>(
+      node, &YGStyle::positionType, positionType);
 }
-YGPositionType YGNodeStyleGetPositionType(const YGNodeRef node) {
-  return node->getStyle().positionType;
+YOGA_EXPORT YGPositionType
+YGNodeStyleGetPositionType(const YGNodeConstRef node) {
+  return node->getStyle().positionType();
 }
 
-void YGNodeStyleSetFlexWrap(const YGNodeRef node, const YGWrap flexWrap) {
-  YG_NODE_STYLE_SET(node, flexWrap, flexWrap);
+YOGA_EXPORT void YGNodeStyleSetFlexWrap(
+    const YGNodeRef node,
+    const YGWrap flexWrap) {
+  updateStyle<MSVC_HINT(flexWrap)>(node, &YGStyle::flexWrap, flexWrap);
 }
-YGWrap YGNodeStyleGetFlexWrap(const YGNodeRef node) {
-  return node->getStyle().flexWrap;
+YOGA_EXPORT YGWrap YGNodeStyleGetFlexWrap(const YGNodeConstRef node) {
+  return node->getStyle().flexWrap();
 }
 
-void YGNodeStyleSetOverflow(const YGNodeRef node, const YGOverflow overflow) {
-  YG_NODE_STYLE_SET(node, overflow, overflow);
+YOGA_EXPORT void YGNodeStyleSetOverflow(
+    const YGNodeRef node,
+    const YGOverflow overflow) {
+  updateStyle<MSVC_HINT(overflow)>(node, &YGStyle::overflow, overflow);
 }
-YGOverflow YGNodeStyleGetOverflow(const YGNodeRef node) {
-  return node->getStyle().overflow;
+YOGA_EXPORT YGOverflow YGNodeStyleGetOverflow(const YGNodeConstRef node) {
+  return node->getStyle().overflow();
 }
 
-void YGNodeStyleSetDisplay(const YGNodeRef node, const YGDisplay display) {
-  YG_NODE_STYLE_SET(node, display, display);
+YOGA_EXPORT void YGNodeStyleSetDisplay(
+    const YGNodeRef node,
+    const YGDisplay display) {
+  updateStyle<MSVC_HINT(display)>(node, &YGStyle::display, display);
 }
-YGDisplay YGNodeStyleGetDisplay(const YGNodeRef node) {
-  return node->getStyle().display;
+YOGA_EXPORT YGDisplay YGNodeStyleGetDisplay(const YGNodeConstRef node) {
+  return node->getStyle().display();
 }
 
 // TODO(T26792433): Change the API to accept YGFloatOptional.
-void YGNodeStyleSetFlex(const YGNodeRef node, const float flex) {
-  if (node->getStyle().flex != flex) {
-    node->getStyle().flex =
-        YGFloatIsUndefined(flex) ? YGFloatOptional() : YGFloatOptional(flex);
-    node->markDirtyAndPropogate();
-  }
+YOGA_EXPORT void YGNodeStyleSetFlex(const YGNodeRef node, const float flex) {
+  updateStyle<MSVC_HINT(flex)>(node, &YGStyle::flex, YGFloatOptional{flex});
 }
 
 // TODO(T26792433): Change the API to accept YGFloatOptional.
-float YGNodeStyleGetFlex(const YGNodeRef node) {
-  return node->getStyle().flex.isUndefined() ? YGUndefined
-                                             : node->getStyle().flex.unwrap();
+YOGA_EXPORT float YGNodeStyleGetFlex(const YGNodeConstRef node) {
+  return node->getStyle().flex().isUndefined()
+      ? YGUndefined
+      : node->getStyle().flex().unwrap();
 }
 
 // TODO(T26792433): Change the API to accept YGFloatOptional.
-void YGNodeStyleSetFlexGrow(const YGNodeRef node, const float flexGrow) {
-  if (node->getStyle().flexGrow != flexGrow) {
-    node->getStyle().flexGrow = YGFloatIsUndefined(flexGrow)
-        ? YGFloatOptional()
-        : YGFloatOptional(flexGrow);
-    node->markDirtyAndPropogate();
-  }
+YOGA_EXPORT void YGNodeStyleSetFlexGrow(
+    const YGNodeRef node,
+    const float flexGrow) {
+  updateStyle<MSVC_HINT(flexGrow)>(
+      node, &YGStyle::flexGrow, YGFloatOptional{flexGrow});
 }
 
 // TODO(T26792433): Change the API to accept YGFloatOptional.
-void YGNodeStyleSetFlexShrink(const YGNodeRef node, const float flexShrink) {
-  if (node->getStyle().flexShrink != flexShrink) {
-    node->getStyle().flexShrink = YGFloatIsUndefined(flexShrink)
-        ? YGFloatOptional()
-        : YGFloatOptional(flexShrink);
-    node->markDirtyAndPropogate();
-  }
+YOGA_EXPORT void YGNodeStyleSetFlexShrink(
+    const YGNodeRef node,
+    const float flexShrink) {
+  updateStyle<MSVC_HINT(flexShrink)>(
+      node, &YGStyle::flexShrink, YGFloatOptional{flexShrink});
 }
 
-YGValue YGNodeStyleGetFlexBasis(const YGNodeRef node) {
-  YGValue flexBasis = node->getStyle().flexBasis;
+YOGA_EXPORT YGValue YGNodeStyleGetFlexBasis(const YGNodeConstRef node) {
+  YGValue flexBasis = node->getStyle().flexBasis();
   if (flexBasis.unit == YGUnitUndefined || flexBasis.unit == YGUnitAuto) {
     // TODO(T26792433): Get rid off the use of YGUndefined at client side
     flexBasis.value = YGUndefined;
@@ -812,157 +691,293 @@ YGValue YGNodeStyleGetFlexBasis(const YGNodeRef node) {
   return flexBasis;
 }
 
-void YGNodeStyleSetFlexBasis(const YGNodeRef node, const float flexBasis) {
+YOGA_EXPORT void YGNodeStyleSetFlexBasis(
+    const YGNodeRef node,
+    const float flexBasis) {
   auto value = detail::CompactValue::ofMaybe<YGUnitPoint>(flexBasis);
-  if (node->getStyle().flexBasis != value) {
-    node->getStyle().flexBasis = value;
-    node->markDirtyAndPropogate();
-  }
+  updateStyle<MSVC_HINT(flexBasis)>(node, &YGStyle::flexBasis, value);
 }
 
-void YGNodeStyleSetFlexBasisPercent(
+YOGA_EXPORT void YGNodeStyleSetFlexBasisPercent(
     const YGNodeRef node,
     const float flexBasisPercent) {
   auto value = detail::CompactValue::ofMaybe<YGUnitPercent>(flexBasisPercent);
-  if (node->getStyle().flexBasis != value) {
-    node->getStyle().flexBasis = value;
-    node->markDirtyAndPropogate();
-  }
+  updateStyle<MSVC_HINT(flexBasis)>(node, &YGStyle::flexBasis, value);
 }
 
-void YGNodeStyleSetFlexBasisAuto(const YGNodeRef node) {
-  if (node->getStyle().flexBasis != detail::CompactValue::ofAuto()) {
-    node->getStyle().flexBasis = detail::CompactValue::ofAuto();
-    node->markDirtyAndPropogate();
-  }
+YOGA_EXPORT void YGNodeStyleSetFlexBasisAuto(const YGNodeRef node) {
+  updateStyle<MSVC_HINT(flexBasis)>(
+      node, &YGStyle::flexBasis, detail::CompactValue::ofAuto());
+}
+
+YOGA_EXPORT void YGNodeStyleSetPosition(
+    YGNodeRef node,
+    YGEdge edge,
+    float points) {
+  auto value = detail::CompactValue::ofMaybe<YGUnitPoint>(points);
+  updateIndexedStyleProp<MSVC_HINT(position)>(
+      node, &YGStyle::position, edge, value);
+}
+YOGA_EXPORT void YGNodeStyleSetPositionPercent(
+    YGNodeRef node,
+    YGEdge edge,
+    float percent) {
+  auto value = detail::CompactValue::ofMaybe<YGUnitPercent>(percent);
+  updateIndexedStyleProp<MSVC_HINT(position)>(
+      node, &YGStyle::position, edge, value);
+}
+YOGA_EXPORT YGValue YGNodeStyleGetPosition(YGNodeConstRef node, YGEdge edge) {
+  return node->getStyle().position()[edge];
 }
 
-YG_NODE_STYLE_EDGE_PROPERTY_UNIT_IMPL(YGValue, Position, position, position);
-YG_NODE_STYLE_EDGE_PROPERTY_UNIT_IMPL(YGValue, Margin, margin, margin);
-YG_NODE_STYLE_EDGE_PROPERTY_UNIT_AUTO_IMPL(YGValue, Margin, margin);
-YG_NODE_STYLE_EDGE_PROPERTY_UNIT_IMPL(YGValue, Padding, padding, padding);
+YOGA_EXPORT void YGNodeStyleSetMargin(
+    YGNodeRef node,
+    YGEdge edge,
+    float points) {
+  auto value = detail::CompactValue::ofMaybe<YGUnitPoint>(points);
+  updateIndexedStyleProp<MSVC_HINT(margin)>(
+      node, &YGStyle::margin, edge, value);
+}
+YOGA_EXPORT void YGNodeStyleSetMarginPercent(
+    YGNodeRef node,
+    YGEdge edge,
+    float percent) {
+  auto value = detail::CompactValue::ofMaybe<YGUnitPercent>(percent);
+  updateIndexedStyleProp<MSVC_HINT(margin)>(
+      node, &YGStyle::margin, edge, value);
+}
+YOGA_EXPORT void YGNodeStyleSetMarginAuto(YGNodeRef node, YGEdge edge) {
+  updateIndexedStyleProp<MSVC_HINT(margin)>(
+      node, &YGStyle::margin, edge, detail::CompactValue::ofAuto());
+}
+YOGA_EXPORT YGValue YGNodeStyleGetMargin(YGNodeConstRef node, YGEdge edge) {
+  return node->getStyle().margin()[edge];
+}
+
+YOGA_EXPORT void YGNodeStyleSetPadding(
+    YGNodeRef node,
+    YGEdge edge,
+    float points) {
+  auto value = detail::CompactValue::ofMaybe<YGUnitPoint>(points);
+  updateIndexedStyleProp<MSVC_HINT(padding)>(
+      node, &YGStyle::padding, edge, value);
+}
+YOGA_EXPORT void YGNodeStyleSetPaddingPercent(
+    YGNodeRef node,
+    YGEdge edge,
+    float percent) {
+  auto value = detail::CompactValue::ofMaybe<YGUnitPercent>(percent);
+  updateIndexedStyleProp<MSVC_HINT(padding)>(
+      node, &YGStyle::padding, edge, value);
+}
+YOGA_EXPORT YGValue YGNodeStyleGetPadding(YGNodeConstRef node, YGEdge edge) {
+  return node->getStyle().padding()[edge];
+}
 
 // TODO(T26792433): Change the API to accept YGFloatOptional.
-void YGNodeStyleSetBorder(
+YOGA_EXPORT void YGNodeStyleSetBorder(
     const YGNodeRef node,
     const YGEdge edge,
     const float border) {
   auto value = detail::CompactValue::ofMaybe<YGUnitPoint>(border);
-  if (node->getStyle().border[edge] != value) {
-    node->getStyle().border[edge] = value;
-    node->markDirtyAndPropogate();
-  }
+  updateIndexedStyleProp<MSVC_HINT(border)>(
+      node, &YGStyle::border, edge, value);
 }
 
-float YGNodeStyleGetBorder(const YGNodeRef node, const YGEdge edge) {
-  if (node->getStyle().border[edge].isUndefined() ||
-      node->getStyle().border[edge].isAuto()) {
+YOGA_EXPORT float YGNodeStyleGetBorder(
+    const YGNodeConstRef node,
+    const YGEdge edge) {
+  auto border = node->getStyle().border()[edge];
+  if (border.isUndefined() || border.isAuto()) {
     // TODO(T26792433): Rather than returning YGUndefined, change the api to
     // return YGFloatOptional.
     return YGUndefined;
   }
 
-  auto border = (YGValue) node->getStyle().border[edge];
-  return border.value;
+  return static_cast<YGValue>(border).value;
 }
 
 // Yoga specific properties, not compatible with flexbox specification
 
 // TODO(T26792433): Change the API to accept YGFloatOptional.
-float YGNodeStyleGetAspectRatio(const YGNodeRef node) {
-  const YGFloatOptional op = node->getStyle().aspectRatio;
+YOGA_EXPORT float YGNodeStyleGetAspectRatio(const YGNodeConstRef node) {
+  const YGFloatOptional op = node->getStyle().aspectRatio();
   return op.isUndefined() ? YGUndefined : op.unwrap();
 }
 
 // TODO(T26792433): Change the API to accept YGFloatOptional.
-void YGNodeStyleSetAspectRatio(const YGNodeRef node, const float aspectRatio) {
-  if (node->getStyle().aspectRatio != aspectRatio) {
-    node->getStyle().aspectRatio = YGFloatOptional(aspectRatio);
-    node->markDirtyAndPropogate();
-  }
+YOGA_EXPORT void YGNodeStyleSetAspectRatio(
+    const YGNodeRef node,
+    const float aspectRatio) {
+  updateStyle<MSVC_HINT(aspectRatio)>(
+      node, &YGStyle::aspectRatio, YGFloatOptional{aspectRatio});
 }
 
-YG_NODE_STYLE_PROPERTY_UNIT_AUTO_IMPL(
-    YGValue,
-    Width,
-    width,
-    dimensions[YGDimensionWidth]);
-YG_NODE_STYLE_PROPERTY_UNIT_AUTO_IMPL(
-    YGValue,
-    Height,
-    height,
-    dimensions[YGDimensionHeight]);
+YOGA_EXPORT void YGNodeStyleSetWidth(YGNodeRef node, float points) {
+  auto value = detail::CompactValue::ofMaybe<YGUnitPoint>(points);
+  updateIndexedStyleProp<MSVC_HINT(dimensions)>(
+      node, &YGStyle::dimensions, YGDimensionWidth, value);
+}
+YOGA_EXPORT void YGNodeStyleSetWidthPercent(YGNodeRef node, float percent) {
+  auto value = detail::CompactValue::ofMaybe<YGUnitPercent>(percent);
+  updateIndexedStyleProp<MSVC_HINT(dimensions)>(
+      node, &YGStyle::dimensions, YGDimensionWidth, value);
+}
+YOGA_EXPORT void YGNodeStyleSetWidthAuto(YGNodeRef node) {
+  updateIndexedStyleProp<MSVC_HINT(dimensions)>(
+      node,
+      &YGStyle::dimensions,
+      YGDimensionWidth,
+      detail::CompactValue::ofAuto());
+}
+YOGA_EXPORT YGValue YGNodeStyleGetWidth(YGNodeConstRef node) {
+  return node->getStyle().dimensions()[YGDimensionWidth];
+}
 
-void YGNodeStyleSetMinWidth(const YGNodeRef node, const float minWidth) {
-  DimensionProp<&YGStyle::minDimensions>::set<YGDimensionWidth, YGUnitPoint>(
-      node, minWidth);
+YOGA_EXPORT void YGNodeStyleSetHeight(YGNodeRef node, float points) {
+  auto value = detail::CompactValue::ofMaybe<YGUnitPoint>(points);
+  updateIndexedStyleProp<MSVC_HINT(dimensions)>(
+      node, &YGStyle::dimensions, YGDimensionHeight, value);
+}
+YOGA_EXPORT void YGNodeStyleSetHeightPercent(YGNodeRef node, float percent) {
+  auto value = detail::CompactValue::ofMaybe<YGUnitPercent>(percent);
+  updateIndexedStyleProp<MSVC_HINT(dimensions)>(
+      node, &YGStyle::dimensions, YGDimensionHeight, value);
+}
+YOGA_EXPORT void YGNodeStyleSetHeightAuto(YGNodeRef node) {
+  updateIndexedStyleProp<MSVC_HINT(dimensions)>(
+      node,
+      &YGStyle::dimensions,
+      YGDimensionHeight,
+      detail::CompactValue::ofAuto());
 }
-void YGNodeStyleSetMinWidthPercent(const YGNodeRef node, const float minWidth) {
-  DimensionProp<&YGStyle::minDimensions>::set<YGDimensionWidth, YGUnitPercent>(
-      node, minWidth);
+YOGA_EXPORT YGValue YGNodeStyleGetHeight(YGNodeConstRef node) {
+  return node->getStyle().dimensions()[YGDimensionHeight];
 }
-YGValue YGNodeStyleGetMinWidth(const YGNodeRef node) {
-  return DimensionProp<&YGStyle::minDimensions>::get<YGDimensionWidth>(node);
+
+YOGA_EXPORT void YGNodeStyleSetMinWidth(
+    const YGNodeRef node,
+    const float minWidth) {
+  auto value = detail::CompactValue::ofMaybe<YGUnitPoint>(minWidth);
+  updateIndexedStyleProp<MSVC_HINT(minDimensions)>(
+      node, &YGStyle::minDimensions, YGDimensionWidth, value);
+}
+YOGA_EXPORT void YGNodeStyleSetMinWidthPercent(
+    const YGNodeRef node,
+    const float minWidth) {
+  auto value = detail::CompactValue::ofMaybe<YGUnitPercent>(minWidth);
+  updateIndexedStyleProp<MSVC_HINT(minDimensions)>(
+      node, &YGStyle::minDimensions, YGDimensionWidth, value);
+}
+YOGA_EXPORT YGValue YGNodeStyleGetMinWidth(const YGNodeConstRef node) {
+  return node->getStyle().minDimensions()[YGDimensionWidth];
 };
 
-void YGNodeStyleSetMinHeight(const YGNodeRef node, const float minHeight) {
-  DimensionProp<&YGStyle::minDimensions>::set<YGDimensionHeight, YGUnitPoint>(
-      node, minHeight);
+YOGA_EXPORT void YGNodeStyleSetMinHeight(
+    const YGNodeRef node,
+    const float minHeight) {
+  auto value = detail::CompactValue::ofMaybe<YGUnitPoint>(minHeight);
+  updateIndexedStyleProp<MSVC_HINT(minDimensions)>(
+      node, &YGStyle::minDimensions, YGDimensionHeight, value);
 }
-void YGNodeStyleSetMinHeightPercent(
+YOGA_EXPORT void YGNodeStyleSetMinHeightPercent(
     const YGNodeRef node,
     const float minHeight) {
-  DimensionProp<&YGStyle::minDimensions>::set<YGDimensionHeight, YGUnitPercent>(
-      node, minHeight);
+  auto value = detail::CompactValue::ofMaybe<YGUnitPercent>(minHeight);
+  updateIndexedStyleProp<MSVC_HINT(minDimensions)>(
+      node, &YGStyle::minDimensions, YGDimensionHeight, value);
 }
-YGValue YGNodeStyleGetMinHeight(const YGNodeRef node) {
-  return DimensionProp<&YGStyle::minDimensions>::get<YGDimensionHeight>(node);
+YOGA_EXPORT YGValue YGNodeStyleGetMinHeight(const YGNodeConstRef node) {
+  return node->getStyle().minDimensions()[YGDimensionHeight];
 };
 
-void YGNodeStyleSetMaxWidth(const YGNodeRef node, const float maxWidth) {
-  DimensionProp<&YGStyle::maxDimensions>::set<YGDimensionWidth, YGUnitPoint>(
-      node, maxWidth);
+YOGA_EXPORT void YGNodeStyleSetMaxWidth(
+    const YGNodeRef node,
+    const float maxWidth) {
+  auto value = detail::CompactValue::ofMaybe<YGUnitPoint>(maxWidth);
+  updateIndexedStyleProp<MSVC_HINT(maxDimensions)>(
+      node, &YGStyle::maxDimensions, YGDimensionWidth, value);
 }
-void YGNodeStyleSetMaxWidthPercent(const YGNodeRef node, const float maxWidth) {
-  DimensionProp<&YGStyle::maxDimensions>::set<YGDimensionWidth, YGUnitPercent>(
-      node, maxWidth);
+YOGA_EXPORT void YGNodeStyleSetMaxWidthPercent(
+    const YGNodeRef node,
+    const float maxWidth) {
+  auto value = detail::CompactValue::ofMaybe<YGUnitPercent>(maxWidth);
+  updateIndexedStyleProp<MSVC_HINT(maxDimensions)>(
+      node, &YGStyle::maxDimensions, YGDimensionWidth, value);
 }
-YGValue YGNodeStyleGetMaxWidth(const YGNodeRef node) {
-  return DimensionProp<&YGStyle::maxDimensions>::get<YGDimensionWidth>(node);
+YOGA_EXPORT YGValue YGNodeStyleGetMaxWidth(const YGNodeConstRef node) {
+  return node->getStyle().maxDimensions()[YGDimensionWidth];
 };
 
-void YGNodeStyleSetMaxHeight(const YGNodeRef node, const float maxHeight) {
-  DimensionProp<&YGStyle::maxDimensions>::set<YGDimensionHeight, YGUnitPoint>(
-      node, maxHeight);
+YOGA_EXPORT void YGNodeStyleSetMaxHeight(
+    const YGNodeRef node,
+    const float maxHeight) {
+  auto value = detail::CompactValue::ofMaybe<YGUnitPoint>(maxHeight);
+  updateIndexedStyleProp<MSVC_HINT(maxDimensions)>(
+      node, &YGStyle::maxDimensions, YGDimensionHeight, value);
 }
-void YGNodeStyleSetMaxHeightPercent(
+YOGA_EXPORT void YGNodeStyleSetMaxHeightPercent(
     const YGNodeRef node,
     const float maxHeight) {
-  DimensionProp<&YGStyle::maxDimensions>::set<YGDimensionHeight, YGUnitPercent>(
-      node, maxHeight);
+  auto value = detail::CompactValue::ofMaybe<YGUnitPercent>(maxHeight);
+  updateIndexedStyleProp<MSVC_HINT(maxDimensions)>(
+      node, &YGStyle::maxDimensions, YGDimensionHeight, value);
 }
-YGValue YGNodeStyleGetMaxHeight(const YGNodeRef node) {
-  return DimensionProp<&YGStyle::maxDimensions>::get<YGDimensionHeight>(node);
+YOGA_EXPORT YGValue YGNodeStyleGetMaxHeight(const YGNodeConstRef node) {
+  return node->getStyle().maxDimensions()[YGDimensionHeight];
 };
 
+#define YG_NODE_LAYOUT_PROPERTY_IMPL(type, name, instanceName)   \
+  YOGA_EXPORT type YGNodeLayoutGet##name(const YGNodeRef node) { \
+    return node->getLayout().instanceName;                       \
+  }
+
+#define YG_NODE_LAYOUT_RESOLVED_PROPERTY_IMPL(type, name, instanceName) \
+  YOGA_EXPORT type YGNodeLayoutGet##name(                               \
+      const YGNodeRef node, const YGEdge edge) {                        \
+    YGAssertWithNode(                                                   \
+        node,                                                           \
+        edge <= YGEdgeEnd,                                              \
+        "Cannot get layout properties of multi-edge shorthands");       \
+                                                                        \
+    if (edge == YGEdgeStart) {                                          \
+      if (node->getLayout().direction() == YGDirectionRTL) {            \
+        return node->getLayout().instanceName[YGEdgeRight];             \
+      } else {                                                          \
+        return node->getLayout().instanceName[YGEdgeLeft];              \
+      }                                                                 \
+    }                                                                   \
+                                                                        \
+    if (edge == YGEdgeEnd) {                                            \
+      if (node->getLayout().direction() == YGDirectionRTL) {            \
+        return node->getLayout().instanceName[YGEdgeLeft];              \
+      } else {                                                          \
+        return node->getLayout().instanceName[YGEdgeRight];             \
+      }                                                                 \
+    }                                                                   \
+                                                                        \
+    return node->getLayout().instanceName[edge];                        \
+  }
+
 YG_NODE_LAYOUT_PROPERTY_IMPL(float, Left, position[YGEdgeLeft]);
 YG_NODE_LAYOUT_PROPERTY_IMPL(float, Top, position[YGEdgeTop]);
 YG_NODE_LAYOUT_PROPERTY_IMPL(float, Right, position[YGEdgeRight]);
 YG_NODE_LAYOUT_PROPERTY_IMPL(float, Bottom, position[YGEdgeBottom]);
 YG_NODE_LAYOUT_PROPERTY_IMPL(float, Width, dimensions[YGDimensionWidth]);
 YG_NODE_LAYOUT_PROPERTY_IMPL(float, Height, dimensions[YGDimensionHeight]);
-YG_NODE_LAYOUT_PROPERTY_IMPL(YGDirection, Direction, direction);
-YG_NODE_LAYOUT_PROPERTY_IMPL(bool, HadOverflow, hadOverflow);
+YG_NODE_LAYOUT_PROPERTY_IMPL(YGDirection, Direction, direction());
+YG_NODE_LAYOUT_PROPERTY_IMPL(bool, HadOverflow, hadOverflow());
 
 YG_NODE_LAYOUT_RESOLVED_PROPERTY_IMPL(float, Margin, margin);
 YG_NODE_LAYOUT_RESOLVED_PROPERTY_IMPL(float, Border, border);
 YG_NODE_LAYOUT_RESOLVED_PROPERTY_IMPL(float, Padding, padding);
 
-bool YGNodeLayoutGetDidLegacyStretchFlagAffectLayout(const YGNodeRef node) {
-  return node->getLayout().doesLegacyStretchFlagAffectsLayout;
+YOGA_EXPORT bool YGNodeLayoutGetDidLegacyStretchFlagAffectLayout(
+    const YGNodeRef node) {
+  return node->getLayout().doesLegacyStretchFlagAffectsLayout();
 }
 
-uint32_t gCurrentGenerationCount = 0;
+std::atomic<uint32_t> gCurrentGenerationCount(0);
 
 bool YGLayoutNodeInternal(
     const YGNodeRef node,
@@ -974,10 +989,12 @@ bool YGLayoutNodeInternal(
     const float ownerWidth,
     const float ownerHeight,
     const bool performLayout,
-    const char* reason,
+    const LayoutPassReason reason,
     const YGConfigRef config,
-    YGMarkerLayoutData& layoutMarkerData,
-    void* const layoutContext);
+    LayoutData& layoutMarkerData,
+    void* const layoutContext,
+    const uint32_t depth,
+    const uint32_t generationCount);
 
 #ifdef DEBUG
 static void YGNodePrintInternal(
@@ -988,7 +1005,9 @@ static void YGNodePrintInternal(
   Log::log(node, YGLogLevelDebug, nullptr, str.c_str());
 }
 
-void YGNodePrint(const YGNodeRef node, const YGPrintOptions options) {
+YOGA_EXPORT void YGNodePrint(
+    const YGNodeRef node,
+    const YGPrintOptions options) {
   YGNodePrintInternal(node, options);
 }
 #endif
@@ -1009,7 +1028,7 @@ static const std::array<YGDimension, 4> dim = {
     {YGDimensionHeight, YGDimensionHeight, YGDimensionWidth, YGDimensionWidth}};
 
 static inline float YGNodePaddingAndBorderForAxis(
-    const YGNodeRef node,
+    const YGNodeConstRef node,
     const YGFlexDirection axis,
     const float widthSize) {
   return (node->getLeadingPaddingAndBorder(axis, widthSize) +
@@ -1017,14 +1036,12 @@ static inline float YGNodePaddingAndBorderForAxis(
       .unwrap();
 }
 
-static inline YGAlign YGNodeAlignItem(
-    const YGNodeRef node,
-    const YGNodeRef child) {
-  const YGAlign align = child->getStyle().alignSelf == YGAlignAuto
-      ? node->getStyle().alignItems
-      : child->getStyle().alignSelf;
+static inline YGAlign YGNodeAlignItem(const YGNode* node, const YGNode* child) {
+  const YGAlign align = child->getStyle().alignSelf() == YGAlignAuto
+      ? node->getStyle().alignItems()
+      : child->getStyle().alignSelf();
   if (align == YGAlignBaseline &&
-      YGFlexDirectionIsColumn(node->getStyle().flexDirection)) {
+      YGFlexDirectionIsColumn(node->getStyle().flexDirection())) {
     return YGAlignFlexStart;
   }
   return align;
@@ -1032,12 +1049,16 @@ static inline YGAlign YGNodeAlignItem(
 
 static float YGBaseline(const YGNodeRef node, void* layoutContext) {
   if (node->hasBaselineFunc()) {
-    const float baseline = marker::MarkerSection<YGMarkerBaselineFn>::wrap(
-        node,
-        &YGNode::baseline,
+
+    Event::publish<Event::NodeBaselineStart>(node);
+
+    const float baseline = node->baseline(
         node->getLayout().measuredDimensions[YGDimensionWidth],
         node->getLayout().measuredDimensions[YGDimensionHeight],
         layoutContext);
+
+    Event::publish<Event::NodeBaselineEnd>(node);
+
     YGAssertWithNode(
         node,
         !YGFloatIsUndefined(baseline),
@@ -1052,7 +1073,7 @@ static float YGBaseline(const YGNodeRef node, void* layoutContext) {
     if (child->getLineIndex() > 0) {
       break;
     }
-    if (child->getStyle().positionType == YGPositionTypeAbsolute) {
+    if (child->getStyle().positionType() == YGPositionTypeAbsolute) {
       continue;
     }
     if (YGNodeAlignItem(node, child) == YGAlignBaseline ||
@@ -1075,17 +1096,17 @@ static float YGBaseline(const YGNodeRef node, void* layoutContext) {
 }
 
 static bool YGIsBaselineLayout(const YGNodeRef node) {
-  if (YGFlexDirectionIsColumn(node->getStyle().flexDirection)) {
+  if (YGFlexDirectionIsColumn(node->getStyle().flexDirection())) {
     return false;
   }
-  if (node->getStyle().alignItems == YGAlignBaseline) {
+  if (node->getStyle().alignItems() == YGAlignBaseline) {
     return true;
   }
   const uint32_t childCount = YGNodeGetChildCount(node);
   for (uint32_t i = 0; i < childCount; i++) {
     const YGNodeRef child = YGNodeGetChild(node, i);
-    if (child->getStyle().positionType == YGPositionTypeRelative &&
-        child->getStyle().alignSelf == YGAlignBaseline) {
+    if (child->getStyle().positionType() != YGPositionTypeAbsolute &&
+        child->getStyle().alignSelf() == YGAlignBaseline) {
       return true;
     }
   }
@@ -1128,7 +1149,7 @@ static inline bool YGNodeIsLayoutDimDefined(
 }
 
 static YGFloatOptional YGNodeBoundAxisWithinMinAndMax(
-    const YGNodeRef node,
+    const YGNodeConstRef node,
     const YGFlexDirection axis,
     const YGFloatOptional value,
     const float axisSize) {
@@ -1137,14 +1158,14 @@ static YGFloatOptional YGNodeBoundAxisWithinMinAndMax(
 
   if (YGFlexDirectionIsColumn(axis)) {
     min = YGResolveValue(
-        node->getStyle().minDimensions[YGDimensionHeight], axisSize);
+        node->getStyle().minDimensions()[YGDimensionHeight], axisSize);
     max = YGResolveValue(
-        node->getStyle().maxDimensions[YGDimensionHeight], axisSize);
+        node->getStyle().maxDimensions()[YGDimensionHeight], axisSize);
   } else if (YGFlexDirectionIsRow(axis)) {
     min = YGResolveValue(
-        node->getStyle().minDimensions[YGDimensionWidth], axisSize);
+        node->getStyle().minDimensions()[YGDimensionWidth], axisSize);
     max = YGResolveValue(
-        node->getStyle().maxDimensions[YGDimensionWidth], axisSize);
+        node->getStyle().maxDimensions()[YGDimensionWidth], axisSize);
   }
 
   if (max >= YGFloatOptional{0} && value > max) {
@@ -1185,14 +1206,15 @@ static void YGNodeSetChildTrailingPosition(
 }
 
 static void YGConstrainMaxSizeForMode(
-    const YGNodeRef node,
+    const YGNodeConstRef node,
     const enum YGFlexDirection axis,
     const float ownerAxisSize,
     const float ownerWidth,
     YGMeasureMode* mode,
     float* size) {
   const YGFloatOptional maxSize =
-      YGResolveValue(node->getStyle().maxDimensions[dim[axis]], ownerAxisSize) +
+      YGResolveValue(
+          node->getStyle().maxDimensions()[dim[axis]], ownerAxisSize) +
       YGFloatOptional(node->getMarginForAxis(axis, ownerWidth));
   switch (*mode) {
     case YGMeasureModeExactly:
@@ -1221,10 +1243,12 @@ static void YGNodeComputeFlexBasisForChild(
     const YGMeasureMode heightMode,
     const YGDirection direction,
     const YGConfigRef config,
-    YGMarkerLayoutData& layoutMarkerData,
-    void* const layoutContext) {
+    LayoutData& layoutMarkerData,
+    void* const layoutContext,
+    const uint32_t depth,
+    const uint32_t generationCount) {
   const YGFlexDirection mainAxis =
-      YGResolveFlexDirection(node->getStyle().flexDirection, direction);
+      YGResolveFlexDirection(node->getStyle().flexDirection(), direction);
   const bool isMainAxisRow = YGFlexDirectionIsRow(mainAxis);
   const float mainAxisSize = isMainAxisRow ? width : height;
   const float mainAxisownerSize = isMainAxisRow ? ownerWidth : ownerHeight;
@@ -1245,8 +1269,7 @@ static void YGNodeComputeFlexBasisForChild(
     if (child->getLayout().computedFlexBasis.isUndefined() ||
         (YGConfigIsExperimentalFeatureEnabled(
              child->getConfig(), YGExperimentalFeatureWebFlexBasis) &&
-         child->getLayout().computedFlexBasisGeneration !=
-             gCurrentGenerationCount)) {
+         child->getLayout().computedFlexBasisGeneration != generationCount)) {
       const YGFloatOptional paddingAndBorder = YGFloatOptional(
           YGNodePaddingAndBorderForAxis(child, mainAxis, ownerWidth));
       child->setLayoutComputedFlexBasis(
@@ -1259,7 +1282,7 @@ static void YGNodeComputeFlexBasisForChild(
 
     child->setLayoutComputedFlexBasis(YGFloatOptionalMax(
         YGResolveValue(
-            child->getResolvedDimension(YGDimensionWidth), ownerWidth),
+            child->getResolvedDimensions()[YGDimensionWidth], ownerWidth),
         paddingAndBorder));
   } else if (!isMainAxisRow && isColumnStyleDimDefined) {
     // The height is definite, so use that as the flex basis.
@@ -1268,7 +1291,7 @@ static void YGNodeComputeFlexBasisForChild(
             child, YGFlexDirectionColumn, ownerWidth));
     child->setLayoutComputedFlexBasis(YGFloatOptionalMax(
         YGResolveValue(
-            child->getResolvedDimension(YGDimensionHeight), ownerHeight),
+            child->getResolvedDimensions()[YGDimensionHeight], ownerHeight),
         paddingAndBorder));
   } else {
     // Compute the flex basis and hypothetical main size (i.e. the clamped flex
@@ -1286,7 +1309,7 @@ static void YGNodeComputeFlexBasisForChild(
     if (isRowStyleDimDefined) {
       childWidth =
           YGResolveValue(
-              child->getResolvedDimension(YGDimensionWidth), ownerWidth)
+              child->getResolvedDimensions()[YGDimensionWidth], ownerWidth)
               .unwrap() +
           marginRow;
       childWidthMeasureMode = YGMeasureModeExactly;
@@ -1294,7 +1317,7 @@ static void YGNodeComputeFlexBasisForChild(
     if (isColumnStyleDimDefined) {
       childHeight =
           YGResolveValue(
-              child->getResolvedDimension(YGDimensionHeight), ownerHeight)
+              child->getResolvedDimensions()[YGDimensionHeight], ownerHeight)
               .unwrap() +
           marginColumn;
       childHeightMeasureMode = YGMeasureModeExactly;
@@ -1302,32 +1325,32 @@ static void YGNodeComputeFlexBasisForChild(
 
     // The W3C spec doesn't say anything about the 'overflow' property, but all
     // major browsers appear to implement the following logic.
-    if ((!isMainAxisRow && node->getStyle().overflow == YGOverflowScroll) ||
-        node->getStyle().overflow != YGOverflowScroll) {
+    if ((!isMainAxisRow && node->getStyle().overflow() == YGOverflowScroll) ||
+        node->getStyle().overflow() != YGOverflowScroll) {
       if (YGFloatIsUndefined(childWidth) && !YGFloatIsUndefined(width)) {
         childWidth = width;
         childWidthMeasureMode = YGMeasureModeAtMost;
       }
     }
 
-    if ((isMainAxisRow && node->getStyle().overflow == YGOverflowScroll) ||
-        node->getStyle().overflow != YGOverflowScroll) {
+    if ((isMainAxisRow && node->getStyle().overflow() == YGOverflowScroll) ||
+        node->getStyle().overflow() != YGOverflowScroll) {
       if (YGFloatIsUndefined(childHeight) && !YGFloatIsUndefined(height)) {
         childHeight = height;
         childHeightMeasureMode = YGMeasureModeAtMost;
       }
     }
 
-    if (!child->getStyle().aspectRatio.isUndefined()) {
+    const auto& childStyle = child->getStyle();
+    if (!childStyle.aspectRatio().isUndefined()) {
       if (!isMainAxisRow && childWidthMeasureMode == YGMeasureModeExactly) {
         childHeight = marginColumn +
-            (childWidth - marginRow) / child->getStyle().aspectRatio.unwrap();
+            (childWidth - marginRow) / childStyle.aspectRatio().unwrap();
         childHeightMeasureMode = YGMeasureModeExactly;
       } else if (
           isMainAxisRow && childHeightMeasureMode == YGMeasureModeExactly) {
         childWidth = marginRow +
-            (childHeight - marginColumn) *
-                child->getStyle().aspectRatio.unwrap();
+            (childHeight - marginColumn) * childStyle.aspectRatio().unwrap();
         childWidthMeasureMode = YGMeasureModeExactly;
       }
     }
@@ -1344,9 +1367,9 @@ static void YGNodeComputeFlexBasisForChild(
         childWidthStretch) {
       childWidth = width;
       childWidthMeasureMode = YGMeasureModeExactly;
-      if (!child->getStyle().aspectRatio.isUndefined()) {
+      if (!childStyle.aspectRatio().isUndefined()) {
         childHeight =
-            (childWidth - marginRow) / child->getStyle().aspectRatio.unwrap();
+            (childWidth - marginRow) / childStyle.aspectRatio().unwrap();
         childHeightMeasureMode = YGMeasureModeExactly;
       }
     }
@@ -1361,9 +1384,9 @@ static void YGNodeComputeFlexBasisForChild(
       childHeight = height;
       childHeightMeasureMode = YGMeasureModeExactly;
 
-      if (!child->getStyle().aspectRatio.isUndefined()) {
-        childWidth = (childHeight - marginColumn) *
-            child->getStyle().aspectRatio.unwrap();
+      if (!childStyle.aspectRatio().isUndefined()) {
+        childWidth =
+            (childHeight - marginColumn) * childStyle.aspectRatio().unwrap();
         childWidthMeasureMode = YGMeasureModeExactly;
       }
     }
@@ -1394,16 +1417,18 @@ static void YGNodeComputeFlexBasisForChild(
         ownerWidth,
         ownerHeight,
         false,
-        "measure",
+        LayoutPassReason::kMeasureChild,
         config,
         layoutMarkerData,
-        layoutContext);
+        layoutContext,
+        depth,
+        generationCount);
 
     child->setLayoutComputedFlexBasis(YGFloatOptional(YGFloatMax(
         child->getLayout().measuredDimensions[dim[mainAxis]],
         YGNodePaddingAndBorderForAxis(child, mainAxis, ownerWidth))));
   }
-  child->setLayoutComputedFlexBasisGeneration(gCurrentGenerationCount);
+  child->setLayoutComputedFlexBasisGeneration(generationCount);
 }
 
 static void YGNodeAbsoluteLayoutChild(
@@ -1414,10 +1439,12 @@ static void YGNodeAbsoluteLayoutChild(
     const float height,
     const YGDirection direction,
     const YGConfigRef config,
-    YGMarkerLayoutData& layoutMarkerData,
-    void* const layoutContext) {
+    LayoutData& layoutMarkerData,
+    void* const layoutContext,
+    const uint32_t depth,
+    const uint32_t generationCount) {
   const YGFlexDirection mainAxis =
-      YGResolveFlexDirection(node->getStyle().flexDirection, direction);
+      YGResolveFlexDirection(node->getStyle().flexDirection(), direction);
   const YGFlexDirection crossAxis = YGFlexDirectionCross(mainAxis, direction);
   const bool isMainAxisRow = YGFlexDirectionIsRow(mainAxis);
 
@@ -1432,7 +1459,7 @@ static void YGNodeAbsoluteLayoutChild(
 
   if (YGNodeIsStyleDimDefined(child, YGFlexDirectionRow, width)) {
     childWidth =
-        YGResolveValue(child->getResolvedDimension(YGDimensionWidth), width)
+        YGResolveValue(child->getResolvedDimensions()[YGDimensionWidth], width)
             .unwrap() +
         marginRow;
   } else {
@@ -1452,9 +1479,9 @@ static void YGNodeAbsoluteLayoutChild(
   }
 
   if (YGNodeIsStyleDimDefined(child, YGFlexDirectionColumn, height)) {
-    childHeight =
-        YGResolveValue(child->getResolvedDimension(YGDimensionHeight), height)
-            .unwrap() +
+    childHeight = YGResolveValue(
+                      child->getResolvedDimensions()[YGDimensionHeight], height)
+                      .unwrap() +
         marginColumn;
   } else {
     // If the child doesn't have a specified height, compute the height based on
@@ -1475,15 +1502,15 @@ static void YGNodeAbsoluteLayoutChild(
   // Exactly one dimension needs to be defined for us to be able to do aspect
   // ratio calculation. One dimension being the anchor and the other being
   // flexible.
+  const auto& childStyle = child->getStyle();
   if (YGFloatIsUndefined(childWidth) ^ YGFloatIsUndefined(childHeight)) {
-    if (!child->getStyle().aspectRatio.isUndefined()) {
+    if (!childStyle.aspectRatio().isUndefined()) {
       if (YGFloatIsUndefined(childWidth)) {
         childWidth = marginRow +
-            (childHeight - marginColumn) *
-                child->getStyle().aspectRatio.unwrap();
+            (childHeight - marginColumn) * childStyle.aspectRatio().unwrap();
       } else if (YGFloatIsUndefined(childHeight)) {
         childHeight = marginColumn +
-            (childWidth - marginRow) / child->getStyle().aspectRatio.unwrap();
+            (childWidth - marginRow) / childStyle.aspectRatio().unwrap();
       }
     }
   }
@@ -1518,10 +1545,12 @@ static void YGNodeAbsoluteLayoutChild(
         childWidth,
         childHeight,
         false,
-        "abs-measure",
+        LayoutPassReason::kAbsMeasureChild,
         config,
         layoutMarkerData,
-        layoutContext);
+        layoutContext,
+        depth,
+        generationCount);
     childWidth = child->getLayout().measuredDimensions[YGDimensionWidth] +
         child->getMarginForAxis(YGFlexDirectionRow, width).unwrap();
     childHeight = child->getLayout().measuredDimensions[YGDimensionHeight] +
@@ -1538,10 +1567,12 @@ static void YGNodeAbsoluteLayoutChild(
       childWidth,
       childHeight,
       true,
-      "abs-layout",
+      LayoutPassReason::kAbsLayout,
       config,
       layoutMarkerData,
-      layoutContext);
+      layoutContext,
+      depth,
+      generationCount);
 
   if (child->isTrailingPosDefined(mainAxis) &&
       !child->isLeadingPositionDefined(mainAxis)) {
@@ -1555,7 +1586,7 @@ static void YGNodeAbsoluteLayoutChild(
         leading[mainAxis]);
   } else if (
       !child->isLeadingPositionDefined(mainAxis) &&
-      node->getStyle().justifyContent == YGJustifyCenter) {
+      node->getStyle().justifyContent() == YGJustifyCenter) {
     child->setLayoutPosition(
         (node->getLayout().measuredDimensions[dim[mainAxis]] -
          child->getLayout().measuredDimensions[dim[mainAxis]]) /
@@ -1563,7 +1594,7 @@ static void YGNodeAbsoluteLayoutChild(
         leading[mainAxis]);
   } else if (
       !child->isLeadingPositionDefined(mainAxis) &&
-      node->getStyle().justifyContent == YGJustifyFlexEnd) {
+      node->getStyle().justifyContent() == YGJustifyFlexEnd) {
     child->setLayoutPosition(
         (node->getLayout().measuredDimensions[dim[mainAxis]] -
          child->getLayout().measuredDimensions[dim[mainAxis]]),
@@ -1593,7 +1624,7 @@ static void YGNodeAbsoluteLayoutChild(
   } else if (
       !child->isLeadingPositionDefined(crossAxis) &&
       ((YGNodeAlignItem(node, child) == YGAlignFlexEnd) ^
-       (node->getStyle().flexWrap == YGWrapWrapReverse))) {
+       (node->getStyle().flexWrap() == YGWrapWrapReverse))) {
     child->setLayoutPosition(
         (node->getLayout().measuredDimensions[dim[crossAxis]] -
          child->getLayout().measuredDimensions[dim[crossAxis]]),
@@ -1603,66 +1634,83 @@ static void YGNodeAbsoluteLayoutChild(
 
 static void YGNodeWithMeasureFuncSetMeasuredDimensions(
     const YGNodeRef node,
-    const float availableWidth,
-    const float availableHeight,
+    float availableWidth,
+    float availableHeight,
     const YGMeasureMode widthMeasureMode,
     const YGMeasureMode heightMeasureMode,
     const float ownerWidth,
     const float ownerHeight,
-    void* const layoutContext) {
+    LayoutData& layoutMarkerData,
+    void* const layoutContext,
+    const LayoutPassReason reason) {
   YGAssertWithNode(
       node,
       node->hasMeasureFunc(),
       "Expected node to have custom measure function");
 
-  const float paddingAndBorderAxisRow =
-      YGNodePaddingAndBorderForAxis(node, YGFlexDirectionRow, availableWidth);
-  const float paddingAndBorderAxisColumn = YGNodePaddingAndBorderForAxis(
-      node, YGFlexDirectionColumn, availableWidth);
-  const float marginAxisRow =
-      node->getMarginForAxis(YGFlexDirectionRow, availableWidth).unwrap();
-  const float marginAxisColumn =
-      node->getMarginForAxis(YGFlexDirectionColumn, availableWidth).unwrap();
+  if (widthMeasureMode == YGMeasureModeUndefined) {
+    availableWidth = YGUndefined;
+  }
+  if (heightMeasureMode == YGMeasureModeUndefined) {
+    availableHeight = YGUndefined;
+  }
+
+  const auto& padding = node->getLayout().padding;
+  const auto& border = node->getLayout().border;
+  const float paddingAndBorderAxisRow = padding[YGEdgeLeft] +
+      padding[YGEdgeRight] + border[YGEdgeLeft] + border[YGEdgeRight];
+  const float paddingAndBorderAxisColumn = padding[YGEdgeTop] +
+      padding[YGEdgeBottom] + border[YGEdgeTop] + border[YGEdgeBottom];
 
   // We want to make sure we don't call measure with negative size
   const float innerWidth = YGFloatIsUndefined(availableWidth)
       ? availableWidth
-      : YGFloatMax(0, availableWidth - marginAxisRow - paddingAndBorderAxisRow);
+      : YGFloatMax(0, availableWidth - paddingAndBorderAxisRow);
   const float innerHeight = YGFloatIsUndefined(availableHeight)
       ? availableHeight
-      : YGFloatMax(
-            0, availableHeight - marginAxisColumn - paddingAndBorderAxisColumn);
+      : YGFloatMax(0, availableHeight - paddingAndBorderAxisColumn);
 
   if (widthMeasureMode == YGMeasureModeExactly &&
       heightMeasureMode == YGMeasureModeExactly) {
     // Don't bother sizing the text if both dimensions are already defined.
     node->setLayoutMeasuredDimension(
         YGNodeBoundAxis(
-            node,
-            YGFlexDirectionRow,
-            availableWidth - marginAxisRow,
-            ownerWidth,
-            ownerWidth),
+            node, YGFlexDirectionRow, availableWidth, ownerWidth, ownerWidth),
         YGDimensionWidth);
     node->setLayoutMeasuredDimension(
         YGNodeBoundAxis(
             node,
             YGFlexDirectionColumn,
-            availableHeight - marginAxisColumn,
+            availableHeight,
             ownerHeight,
             ownerWidth),
         YGDimensionHeight);
   } else {
+    Event::publish<Event::MeasureCallbackStart>(node);
+
     // Measure the text under the current constraints.
-    const YGSize measuredSize = marker::MarkerSection<YGMarkerMeasure>::wrap(
-        node,
-        &YGNode::measure,
+    const YGSize measuredSize = node->measure(
         innerWidth,
         widthMeasureMode,
         innerHeight,
         heightMeasureMode,
         layoutContext);
 
+    layoutMarkerData.measureCallbacks += 1;
+    layoutMarkerData.measureCallbackReasonsCount[static_cast<size_t>(reason)] +=
+        1;
+
+    Event::publish<Event::MeasureCallbackEnd>(
+        node,
+        {layoutContext,
+         innerWidth,
+         widthMeasureMode,
+         innerHeight,
+         heightMeasureMode,
+         measuredSize.width,
+         measuredSize.height,
+         reason});
+
     node->setLayoutMeasuredDimension(
         YGNodeBoundAxis(
             node,
@@ -1670,7 +1718,7 @@ static void YGNodeWithMeasureFuncSetMeasuredDimensions(
             (widthMeasureMode == YGMeasureModeUndefined ||
              widthMeasureMode == YGMeasureModeAtMost)
                 ? measuredSize.width + paddingAndBorderAxisRow
-                : availableWidth - marginAxisRow,
+                : availableWidth,
             ownerWidth,
             ownerWidth),
         YGDimensionWidth);
@@ -1682,7 +1730,7 @@ static void YGNodeWithMeasureFuncSetMeasuredDimensions(
             (heightMeasureMode == YGMeasureModeUndefined ||
              heightMeasureMode == YGMeasureModeAtMost)
                 ? measuredSize.height + paddingAndBorderAxisColumn
-                : availableHeight - marginAxisColumn,
+                : availableHeight,
             ownerHeight,
             ownerWidth),
         YGDimensionHeight);
@@ -1699,37 +1747,28 @@ static void YGNodeEmptyContainerSetMeasuredDimensions(
     const YGMeasureMode heightMeasureMode,
     const float ownerWidth,
     const float ownerHeight) {
-  const float paddingAndBorderAxisRow =
-      YGNodePaddingAndBorderForAxis(node, YGFlexDirectionRow, ownerWidth);
-  const float paddingAndBorderAxisColumn =
-      YGNodePaddingAndBorderForAxis(node, YGFlexDirectionColumn, ownerWidth);
-  const float marginAxisRow =
-      node->getMarginForAxis(YGFlexDirectionRow, ownerWidth).unwrap();
-  const float marginAxisColumn =
-      node->getMarginForAxis(YGFlexDirectionColumn, ownerWidth).unwrap();
-
+  const auto& padding = node->getLayout().padding;
+  const auto& border = node->getLayout().border;
+
+  float width = availableWidth;
+  if (widthMeasureMode == YGMeasureModeUndefined ||
+      widthMeasureMode == YGMeasureModeAtMost) {
+    width = padding[YGEdgeLeft] + padding[YGEdgeRight] + border[YGEdgeLeft] +
+        border[YGEdgeRight];
+  }
   node->setLayoutMeasuredDimension(
-      YGNodeBoundAxis(
-          node,
-          YGFlexDirectionRow,
-          (widthMeasureMode == YGMeasureModeUndefined ||
-           widthMeasureMode == YGMeasureModeAtMost)
-              ? paddingAndBorderAxisRow
-              : availableWidth - marginAxisRow,
-          ownerWidth,
-          ownerWidth),
+      YGNodeBoundAxis(node, YGFlexDirectionRow, width, ownerWidth, ownerWidth),
       YGDimensionWidth);
 
+  float height = availableHeight;
+  if (heightMeasureMode == YGMeasureModeUndefined ||
+      heightMeasureMode == YGMeasureModeAtMost) {
+    height = padding[YGEdgeTop] + padding[YGEdgeBottom] + border[YGEdgeTop] +
+        border[YGEdgeBottom];
+  }
   node->setLayoutMeasuredDimension(
       YGNodeBoundAxis(
-          node,
-          YGFlexDirectionColumn,
-          (heightMeasureMode == YGMeasureModeUndefined ||
-           heightMeasureMode == YGMeasureModeAtMost)
-              ? paddingAndBorderAxisColumn
-              : availableHeight - marginAxisColumn,
-          ownerHeight,
-          ownerWidth),
+          node, YGFlexDirectionColumn, height, ownerHeight, ownerWidth),
       YGDimensionHeight);
 }
 
@@ -1747,11 +1786,6 @@ static bool YGNodeFixedSizeSetMeasuredDimensions(
        heightMeasureMode == YGMeasureModeAtMost && availableHeight <= 0.0f) ||
       (widthMeasureMode == YGMeasureModeExactly &&
        heightMeasureMode == YGMeasureModeExactly)) {
-    auto marginAxisColumn =
-        node->getMarginForAxis(YGFlexDirectionColumn, ownerWidth).unwrap();
-    auto marginAxisRow =
-        node->getMarginForAxis(YGFlexDirectionRow, ownerWidth).unwrap();
-
     node->setLayoutMeasuredDimension(
         YGNodeBoundAxis(
             node,
@@ -1760,7 +1794,7 @@ static bool YGNodeFixedSizeSetMeasuredDimensions(
                     (widthMeasureMode == YGMeasureModeAtMost &&
                      availableWidth < 0.0f)
                 ? 0.0f
-                : availableWidth - marginAxisRow,
+                : availableWidth,
             ownerWidth,
             ownerWidth),
         YGDimensionWidth);
@@ -1773,7 +1807,7 @@ static bool YGNodeFixedSizeSetMeasuredDimensions(
                     (heightMeasureMode == YGMeasureModeAtMost &&
                      availableHeight < 0.0f)
                 ? 0.0f
-                : availableHeight - marginAxisColumn,
+                : availableHeight,
             ownerHeight,
             ownerWidth),
         YGDimensionHeight);
@@ -1796,33 +1830,25 @@ static void YGZeroOutLayoutRecursivly(
 }
 
 static float YGNodeCalculateAvailableInnerDim(
-    const YGNodeRef node,
-    YGFlexDirection axis,
-    float availableDim,
-    float ownerDim) {
-  YGFlexDirection direction =
-      YGFlexDirectionIsRow(axis) ? YGFlexDirectionRow : YGFlexDirectionColumn;
-  YGDimension dimension =
-      YGFlexDirectionIsRow(axis) ? YGDimensionWidth : YGDimensionHeight;
-
-  const float margin = node->getMarginForAxis(direction, ownerDim).unwrap();
-  const float paddingAndBorder =
-      YGNodePaddingAndBorderForAxis(node, direction, ownerDim);
-
-  float availableInnerDim = availableDim - margin - paddingAndBorder;
+    const YGNodeConstRef node,
+    const YGDimension dimension,
+    const float availableDim,
+    const float paddingAndBorder,
+    const float ownerDim) {
+  float availableInnerDim = availableDim - paddingAndBorder;
   // Max dimension overrides predefined dimension value; Min dimension in turn
   // overrides both of the above
   if (!YGFloatIsUndefined(availableInnerDim)) {
     // We want to make sure our available height does not violate min and max
     // constraints
     const YGFloatOptional minDimensionOptional =
-        YGResolveValue(node->getStyle().minDimensions[dimension], ownerDim);
+        YGResolveValue(node->getStyle().minDimensions()[dimension], ownerDim);
     const float minInnerDim = minDimensionOptional.isUndefined()
         ? 0.0f
         : minDimensionOptional.unwrap() - paddingAndBorder;
 
     const YGFloatOptional maxDimensionOptional =
-        YGResolveValue(node->getStyle().maxDimensions[dimension], ownerDim);
+        YGResolveValue(node->getStyle().maxDimensions()[dimension], ownerDim);
 
     const float maxInnerDim = maxDimensionOptional.isUndefined()
         ? FLT_MAX
@@ -1844,11 +1870,13 @@ static float YGNodeComputeFlexBasisForChildren(
     YGFlexDirection mainAxis,
     const YGConfigRef config,
     bool performLayout,
-    YGMarkerLayoutData& layoutMarkerData,
-    void* const layoutContext) {
+    LayoutData& layoutMarkerData,
+    void* const layoutContext,
+    const uint32_t depth,
+    const uint32_t generationCount) {
   float totalOuterFlexBasis = 0.0f;
   YGNodeRef singleFlexChild = nullptr;
-  YGVector children = node->getChildren();
+  const YGVector& children = node->getChildren();
   YGMeasureMode measureModeMainDim =
       YGFlexDirectionIsRow(mainAxis) ? widthMeasureMode : heightMeasureMode;
   // If there is only one child with flexGrow + flexShrink it means we can set
@@ -1873,7 +1901,7 @@ static float YGNodeComputeFlexBasisForChildren(
 
   for (auto child : children) {
     child->resolveDimension();
-    if (child->getStyle().display == YGDisplayNone) {
+    if (child->getStyle().display() == YGDisplayNone) {
       YGZeroOutLayoutRecursivly(child, layoutContext);
       child->setHasNewLayout(true);
       child->setDirty(false);
@@ -1892,11 +1920,11 @@ static float YGNodeComputeFlexBasisForChildren(
           childDirection, mainDim, crossDim, availableInnerWidth);
     }
 
-    if (child->getStyle().positionType == YGPositionTypeAbsolute) {
+    if (child->getStyle().positionType() == YGPositionTypeAbsolute) {
       continue;
     }
     if (child == singleFlexChild) {
-      child->setLayoutComputedFlexBasisGeneration(gCurrentGenerationCount);
+      child->setLayoutComputedFlexBasisGeneration(generationCount);
       child->setLayoutComputedFlexBasis(YGFloatOptional(0));
     } else {
       YGNodeComputeFlexBasisForChild(
@@ -1911,7 +1939,9 @@ static float YGNodeComputeFlexBasisForChildren(
           direction,
           config,
           layoutMarkerData,
-          layoutContext);
+          layoutContext,
+          depth,
+          generationCount);
     }
 
     totalOuterFlexBasis +=
@@ -1940,15 +1970,15 @@ static YGCollectFlexItemsRowValues YGCalculateCollectFlexItemsRowValues(
 
   float sizeConsumedOnCurrentLineIncludingMinConstraint = 0;
   const YGFlexDirection mainAxis = YGResolveFlexDirection(
-      node->getStyle().flexDirection, node->resolveDirection(ownerDirection));
-  const bool isNodeFlexWrap = node->getStyle().flexWrap != YGWrapNoWrap;
+      node->getStyle().flexDirection(), node->resolveDirection(ownerDirection));
+  const bool isNodeFlexWrap = node->getStyle().flexWrap() != YGWrapNoWrap;
 
   // Add items to the current line until it's full or we run out of items.
   uint32_t endOfLineIndex = startOfLineIndex;
   for (; endOfLineIndex < node->getChildren().size(); endOfLineIndex++) {
     const YGNodeRef child = node->getChild(endOfLineIndex);
-    if (child->getStyle().display == YGDisplayNone ||
-        child->getStyle().positionType == YGPositionTypeAbsolute) {
+    if (child->getStyle().display() == YGDisplayNone ||
+        child->getStyle().positionType() == YGPositionTypeAbsolute) {
       continue;
     }
     child->setLineIndex(lineCount);
@@ -2024,14 +2054,16 @@ static float YGDistributeFreeSpaceSecondPass(
     const YGMeasureMode measureModeCrossDim,
     const bool performLayout,
     const YGConfigRef config,
-    YGMarkerLayoutData& layoutMarkerData,
-    void* const layoutContext) {
+    LayoutData& layoutMarkerData,
+    void* const layoutContext,
+    const uint32_t depth,
+    const uint32_t generationCount) {
   float childFlexBasis = 0;
   float flexShrinkScaledFactor = 0;
   float flexGrowFactor = 0;
   float deltaFreeSpace = 0;
   const bool isMainAxisRow = YGFlexDirectionIsRow(mainAxis);
-  const bool isNodeFlexWrap = node->getStyle().flexWrap != YGWrapNoWrap;
+  const bool isNodeFlexWrap = node->getStyle().flexWrap() != YGWrapNoWrap;
 
   for (auto currentRelativeChild : collectedFlexItemsValues.relativeChildren) {
     childFlexBasis = YGNodeBoundAxisWithinMinAndMax(
@@ -2101,11 +2133,11 @@ static float YGDistributeFreeSpaceSecondPass(
     YGMeasureMode childCrossMeasureMode;
     YGMeasureMode childMainMeasureMode = YGMeasureModeExactly;
 
-    if (!currentRelativeChild->getStyle().aspectRatio.isUndefined()) {
-      childCrossSize = isMainAxisRow ? (childMainSize - marginMain) /
-              currentRelativeChild->getStyle().aspectRatio.unwrap()
-                                     : (childMainSize - marginMain) *
-              currentRelativeChild->getStyle().aspectRatio.unwrap();
+    const auto& childStyle = currentRelativeChild->getStyle();
+    if (!childStyle.aspectRatio().isUndefined()) {
+      childCrossSize = isMainAxisRow
+          ? (childMainSize - marginMain) / childStyle.aspectRatio().unwrap()
+          : (childMainSize - marginMain) * childStyle.aspectRatio().unwrap();
       childCrossMeasureMode = YGMeasureModeExactly;
 
       childCrossSize += marginCross;
@@ -2176,25 +2208,29 @@ static float YGDistributeFreeSpaceSecondPass(
     const YGMeasureMode childHeightMeasureMode =
         !isMainAxisRow ? childMainMeasureMode : childCrossMeasureMode;
 
+    const bool isLayoutPass = performLayout && !requiresStretchLayout;
     // Recursively call the layout algorithm for this child with the updated
     // main size.
     YGLayoutNodeInternal(
         currentRelativeChild,
         childWidth,
         childHeight,
-        node->getLayout().direction,
+        node->getLayout().direction(),
         childWidthMeasureMode,
         childHeightMeasureMode,
         availableInnerWidth,
         availableInnerHeight,
-        performLayout && !requiresStretchLayout,
-        "flex",
+        isLayoutPass,
+        isLayoutPass ? LayoutPassReason::kFlexLayout
+                     : LayoutPassReason::kFlexMeasure,
         config,
         layoutMarkerData,
-        layoutContext);
+        layoutContext,
+        depth,
+        generationCount);
     node->setLayoutHadOverflow(
-        node->getLayout().hadOverflow |
-        currentRelativeChild->getLayout().hadOverflow);
+        node->getLayout().hadOverflow() |
+        currentRelativeChild->getLayout().hadOverflow());
   }
   return deltaFreeSpace;
 }
@@ -2249,7 +2285,8 @@ static void YGDistributeFreeSpaceFirstPass(
           // first and second passes.
           deltaFreeSpace += boundMainSize - childFlexBasis;
           collectedFlexItemsValues.totalFlexShrinkScaledFactors -=
-              flexShrinkScaledFactor;
+              (-currentRelativeChild->resolveFlexShrink() *
+               currentRelativeChild->getLayout().computedFlexBasis.unwrap());
         }
       }
     } else if (
@@ -2321,8 +2358,10 @@ static void YGResolveFlexibleLength(
     const YGMeasureMode measureModeCrossDim,
     const bool performLayout,
     const YGConfigRef config,
-    YGMarkerLayoutData& layoutMarkerData,
-    void* const layoutContext) {
+    LayoutData& layoutMarkerData,
+    void* const layoutContext,
+    const uint32_t depth,
+    const uint32_t generationCount) {
   const float originalFreeSpace = collectedFlexItemsValues.remainingFreeSpace;
   // First pass: detect the flex items whose min/max constraints trigger
   YGDistributeFreeSpaceFirstPass(
@@ -2348,7 +2387,9 @@ static void YGResolveFlexibleLength(
       performLayout,
       config,
       layoutMarkerData,
-      layoutContext);
+      layoutContext,
+      depth,
+      generationCount);
 
   collectedFlexItemsValues.remainingFreeSpace =
       originalFreeSpace - distributedFreeSpace;
@@ -2369,7 +2410,7 @@ static void YGJustifyMainAxis(
     const float availableInnerWidth,
     const bool performLayout,
     void* const layoutContext) {
-  const YGStyle& style = node->getStyle();
+  const auto& style = node->getStyle();
   const float leadingPaddingAndBorderMain =
       node->getLeadingPaddingAndBorder(mainAxis, ownerWidth).unwrap();
   const float trailingPaddingAndBorderMain =
@@ -2378,8 +2419,8 @@ static void YGJustifyMainAxis(
   // remainingFreeSpace is 0 when min main dimension is not given
   if (measureModeMainDim == YGMeasureModeAtMost &&
       collectedFlexItemsValues.remainingFreeSpace > 0) {
-    if (!style.minDimensions[dim[mainAxis]].isUndefined() &&
-        !YGResolveValue(style.minDimensions[dim[mainAxis]], mainAxisownerSize)
+    if (!style.minDimensions()[dim[mainAxis]].isUndefined() &&
+        !YGResolveValue(style.minDimensions()[dim[mainAxis]], mainAxisownerSize)
              .isUndefined()) {
       // This condition makes sure that if the size of main dimension(after
       // considering child nodes main dim, leading and trailing padding etc)
@@ -2389,7 +2430,8 @@ static void YGJustifyMainAxis(
       // `minAvailableMainDim` denotes minimum available space in which child
       // can be laid out, it will exclude space consumed by padding and border.
       const float minAvailableMainDim =
-          YGResolveValue(style.minDimensions[dim[mainAxis]], mainAxisownerSize)
+          YGResolveValue(
+              style.minDimensions()[dim[mainAxis]], mainAxisownerSize)
               .unwrap() -
           leadingPaddingAndBorderMain - trailingPaddingAndBorderMain;
       const float occupiedSpaceByChildNodes =
@@ -2406,7 +2448,7 @@ static void YGJustifyMainAxis(
        i < collectedFlexItemsValues.endOfLineIndex;
        i++) {
     const YGNodeRef child = node->getChild(i);
-    if (child->getStyle().positionType == YGPositionTypeRelative) {
+    if (child->getStyle().positionType() != YGPositionTypeAbsolute) {
       if (child->marginLeadingValue(mainAxis).unit == YGUnitAuto) {
         numberOfAutoMarginsOnCurrentLine++;
       }
@@ -2421,7 +2463,7 @@ static void YGJustifyMainAxis(
   // each two elements.
   float leadingMainDim = 0;
   float betweenMainDim = 0;
-  const YGJustify justifyContent = node->getStyle().justifyContent;
+  const YGJustify justifyContent = node->getStyle().justifyContent();
 
   if (numberOfAutoMarginsOnCurrentLine == 0) {
     switch (justifyContent) {
@@ -2470,10 +2512,10 @@ static void YGJustifyMainAxis(
     const YGNodeRef child = node->getChild(i);
     const YGStyle& childStyle = child->getStyle();
     const YGLayout childLayout = child->getLayout();
-    if (childStyle.display == YGDisplayNone) {
+    if (childStyle.display() == YGDisplayNone) {
       continue;
     }
-    if (childStyle.positionType == YGPositionTypeAbsolute &&
+    if (childStyle.positionType() == YGPositionTypeAbsolute &&
         child->isLeadingPositionDefined(mainAxis)) {
       if (performLayout) {
         // In case the child is position absolute and has left/top being
@@ -2490,7 +2532,7 @@ static void YGJustifyMainAxis(
       // Now that we placed the element, we need to update the variables.
       // We need to do that only for relative elements. Absolute elements do not
       // take part in that phase.
-      if (childStyle.positionType == YGPositionTypeRelative) {
+      if (childStyle.positionType() != YGPositionTypeAbsolute) {
         if (child->marginLeadingValue(mainAxis).unit == YGUnitAuto) {
           collectedFlexItemsValues.mainDim +=
               collectedFlexItemsValues.remainingFreeSpace /
@@ -2646,8 +2688,11 @@ static void YGNodelayoutImpl(
     const float ownerHeight,
     const bool performLayout,
     const YGConfigRef config,
-    YGMarkerLayoutData& layoutMarkerData,
-    void* const layoutContext) {
+    LayoutData& layoutMarkerData,
+    void* const layoutContext,
+    const uint32_t depth,
+    const uint32_t generationCount,
+    const LayoutPassReason reason) {
   YGAssertWithNode(
       node,
       YGFloatIsUndefined(availableWidth)
@@ -2674,31 +2719,37 @@ static void YGNodelayoutImpl(
   const YGFlexDirection flexColumnDirection =
       YGResolveFlexDirection(YGFlexDirectionColumn, direction);
 
-  node->setLayoutMargin(
-      node->getLeadingMargin(flexRowDirection, ownerWidth).unwrap(),
-      YGEdgeStart);
-  node->setLayoutMargin(
-      node->getTrailingMargin(flexRowDirection, ownerWidth).unwrap(),
-      YGEdgeEnd);
-  node->setLayoutMargin(
-      node->getLeadingMargin(flexColumnDirection, ownerWidth).unwrap(),
-      YGEdgeTop);
-  node->setLayoutMargin(
-      node->getTrailingMargin(flexColumnDirection, ownerWidth).unwrap(),
-      YGEdgeBottom);
-
-  node->setLayoutBorder(node->getLeadingBorder(flexRowDirection), YGEdgeStart);
-  node->setLayoutBorder(node->getTrailingBorder(flexRowDirection), YGEdgeEnd);
+  const YGEdge startEdge =
+      direction == YGDirectionLTR ? YGEdgeLeft : YGEdgeRight;
+  const YGEdge endEdge = direction == YGDirectionLTR ? YGEdgeRight : YGEdgeLeft;
+
+  const float marginRowLeading =
+      node->getLeadingMargin(flexRowDirection, ownerWidth).unwrap();
+  node->setLayoutMargin(marginRowLeading, startEdge);
+  const float marginRowTrailing =
+      node->getTrailingMargin(flexRowDirection, ownerWidth).unwrap();
+  node->setLayoutMargin(marginRowTrailing, endEdge);
+  const float marginColumnLeading =
+      node->getLeadingMargin(flexColumnDirection, ownerWidth).unwrap();
+  node->setLayoutMargin(marginColumnLeading, YGEdgeTop);
+  const float marginColumnTrailing =
+      node->getTrailingMargin(flexColumnDirection, ownerWidth).unwrap();
+  node->setLayoutMargin(marginColumnTrailing, YGEdgeBottom);
+
+  const float marginAxisRow = marginRowLeading + marginRowTrailing;
+  const float marginAxisColumn = marginColumnLeading + marginColumnTrailing;
+
+  node->setLayoutBorder(node->getLeadingBorder(flexRowDirection), startEdge);
+  node->setLayoutBorder(node->getTrailingBorder(flexRowDirection), endEdge);
   node->setLayoutBorder(node->getLeadingBorder(flexColumnDirection), YGEdgeTop);
   node->setLayoutBorder(
       node->getTrailingBorder(flexColumnDirection), YGEdgeBottom);
 
   node->setLayoutPadding(
       node->getLeadingPadding(flexRowDirection, ownerWidth).unwrap(),
-      YGEdgeStart);
+      startEdge);
   node->setLayoutPadding(
-      node->getTrailingPadding(flexRowDirection, ownerWidth).unwrap(),
-      YGEdgeEnd);
+      node->getTrailingPadding(flexRowDirection, ownerWidth).unwrap(), endEdge);
   node->setLayoutPadding(
       node->getLeadingPadding(flexColumnDirection, ownerWidth).unwrap(),
       YGEdgeTop);
@@ -2709,13 +2760,15 @@ static void YGNodelayoutImpl(
   if (node->hasMeasureFunc()) {
     YGNodeWithMeasureFuncSetMeasuredDimensions(
         node,
-        availableWidth,
-        availableHeight,
+        availableWidth - marginAxisRow,
+        availableHeight - marginAxisColumn,
         widthMeasureMode,
         heightMeasureMode,
         ownerWidth,
         ownerHeight,
-        layoutContext);
+        layoutMarkerData,
+        layoutContext,
+        reason);
     return;
   }
 
@@ -2723,8 +2776,8 @@ static void YGNodelayoutImpl(
   if (childCount == 0) {
     YGNodeEmptyContainerSetMeasuredDimensions(
         node,
-        availableWidth,
-        availableHeight,
+        availableWidth - marginAxisRow,
+        availableHeight - marginAxisColumn,
         widthMeasureMode,
         heightMeasureMode,
         ownerWidth,
@@ -2737,8 +2790,8 @@ static void YGNodelayoutImpl(
   if (!performLayout &&
       YGNodeFixedSizeSetMeasuredDimensions(
           node,
-          availableWidth,
-          availableHeight,
+          availableWidth - marginAxisRow,
+          availableHeight - marginAxisColumn,
           widthMeasureMode,
           heightMeasureMode,
           ownerWidth,
@@ -2754,20 +2807,22 @@ static void YGNodelayoutImpl(
 
   // STEP 1: CALCULATE VALUES FOR REMAINDER OF ALGORITHM
   const YGFlexDirection mainAxis =
-      YGResolveFlexDirection(node->getStyle().flexDirection, direction);
+      YGResolveFlexDirection(node->getStyle().flexDirection(), direction);
   const YGFlexDirection crossAxis = YGFlexDirectionCross(mainAxis, direction);
   const bool isMainAxisRow = YGFlexDirectionIsRow(mainAxis);
-  const bool isNodeFlexWrap = node->getStyle().flexWrap != YGWrapNoWrap;
+  const bool isNodeFlexWrap = node->getStyle().flexWrap() != YGWrapNoWrap;
 
   const float mainAxisownerSize = isMainAxisRow ? ownerWidth : ownerHeight;
   const float crossAxisownerSize = isMainAxisRow ? ownerHeight : ownerWidth;
 
-  const float leadingPaddingAndBorderCross =
-      node->getLeadingPaddingAndBorder(crossAxis, ownerWidth).unwrap();
   const float paddingAndBorderAxisMain =
       YGNodePaddingAndBorderForAxis(node, mainAxis, ownerWidth);
+  const float leadingPaddingAndBorderCross =
+      node->getLeadingPaddingAndBorder(crossAxis, ownerWidth).unwrap();
+  const float trailingPaddingAndBorderCross =
+      node->getTrailingPaddingAndBorder(crossAxis, ownerWidth).unwrap();
   const float paddingAndBorderAxisCross =
-      YGNodePaddingAndBorderForAxis(node, crossAxis, ownerWidth);
+      leadingPaddingAndBorderCross + trailingPaddingAndBorderCross;
 
   YGMeasureMode measureModeMainDim =
       isMainAxisRow ? widthMeasureMode : heightMeasureMode;
@@ -2779,41 +2834,20 @@ static void YGNodelayoutImpl(
   const float paddingAndBorderAxisColumn =
       isMainAxisRow ? paddingAndBorderAxisCross : paddingAndBorderAxisMain;
 
-  const float marginAxisRow =
-      node->getMarginForAxis(YGFlexDirectionRow, ownerWidth).unwrap();
-  const float marginAxisColumn =
-      node->getMarginForAxis(YGFlexDirectionColumn, ownerWidth).unwrap();
-
-  const float minInnerWidth =
-      YGResolveValue(
-          node->getStyle().minDimensions[YGDimensionWidth], ownerWidth)
-          .unwrap() -
-      paddingAndBorderAxisRow;
-  const float maxInnerWidth =
-      YGResolveValue(
-          node->getStyle().maxDimensions[YGDimensionWidth], ownerWidth)
-          .unwrap() -
-      paddingAndBorderAxisRow;
-  const float minInnerHeight =
-      YGResolveValue(
-          node->getStyle().minDimensions[YGDimensionHeight], ownerHeight)
-          .unwrap() -
-      paddingAndBorderAxisColumn;
-  const float maxInnerHeight =
-      YGResolveValue(
-          node->getStyle().maxDimensions[YGDimensionHeight], ownerHeight)
-          .unwrap() -
-      paddingAndBorderAxisColumn;
-
-  const float minInnerMainDim = isMainAxisRow ? minInnerWidth : minInnerHeight;
-  const float maxInnerMainDim = isMainAxisRow ? maxInnerWidth : maxInnerHeight;
-
   // STEP 2: DETERMINE AVAILABLE SIZE IN MAIN AND CROSS DIRECTIONS
 
   float availableInnerWidth = YGNodeCalculateAvailableInnerDim(
-      node, YGFlexDirectionRow, availableWidth, ownerWidth);
+      node,
+      YGDimensionWidth,
+      availableWidth - marginAxisRow,
+      paddingAndBorderAxisRow,
+      ownerWidth);
   float availableInnerHeight = YGNodeCalculateAvailableInnerDim(
-      node, YGFlexDirectionColumn, availableHeight, ownerHeight);
+      node,
+      YGDimensionHeight,
+      availableHeight - marginAxisColumn,
+      paddingAndBorderAxisColumn,
+      ownerHeight);
 
   float availableInnerMainDim =
       isMainAxisRow ? availableInnerWidth : availableInnerHeight;
@@ -2833,7 +2867,9 @@ static void YGNodelayoutImpl(
       config,
       performLayout,
       layoutMarkerData,
-      layoutContext);
+      layoutContext,
+      depth,
+      generationCount);
 
   const bool flexBasisOverflows = measureModeMainDim == YGMeasureModeUndefined
       ? false
@@ -2883,6 +2919,28 @@ static void YGNodelayoutImpl(
     // If we don't measure with exact main dimension we want to ensure we don't
     // violate min and max
     if (measureModeMainDim != YGMeasureModeExactly) {
+      const auto& minDimensions = node->getStyle().minDimensions();
+      const auto& maxDimensions = node->getStyle().maxDimensions();
+      const float minInnerWidth =
+          YGResolveValue(minDimensions[YGDimensionWidth], ownerWidth).unwrap() -
+          paddingAndBorderAxisRow;
+      const float maxInnerWidth =
+          YGResolveValue(maxDimensions[YGDimensionWidth], ownerWidth).unwrap() -
+          paddingAndBorderAxisRow;
+      const float minInnerHeight =
+          YGResolveValue(minDimensions[YGDimensionHeight], ownerHeight)
+              .unwrap() -
+          paddingAndBorderAxisColumn;
+      const float maxInnerHeight =
+          YGResolveValue(maxDimensions[YGDimensionHeight], ownerHeight)
+              .unwrap() -
+          paddingAndBorderAxisColumn;
+
+      const float minInnerMainDim =
+          isMainAxisRow ? minInnerWidth : minInnerHeight;
+      const float maxInnerMainDim =
+          isMainAxisRow ? maxInnerWidth : maxInnerHeight;
+
       if (!YGFloatIsUndefined(minInnerMainDim) &&
           collectedFlexItemsValues.sizeConsumedOnCurrentLine <
               minInnerMainDim) {
@@ -2941,11 +2999,13 @@ static void YGNodelayoutImpl(
           performLayout,
           config,
           layoutMarkerData,
-          layoutContext);
+          layoutContext,
+          depth,
+          generationCount);
     }
 
     node->setLayoutHadOverflow(
-        node->getLayout().hadOverflow |
+        node->getLayout().hadOverflow() |
         (collectedFlexItemsValues.remainingFreeSpace < 0));
 
     // STEP 6: MAIN-AXIS JUSTIFICATION & CROSS-AXIS SIZE DETERMINATION
@@ -3005,10 +3065,10 @@ static void YGNodelayoutImpl(
     if (performLayout) {
       for (uint32_t i = startOfLineIndex; i < endOfLineIndex; i++) {
         const YGNodeRef child = node->getChild(i);
-        if (child->getStyle().display == YGDisplayNone) {
+        if (child->getStyle().display() == YGDisplayNone) {
           continue;
         }
-        if (child->getStyle().positionType == YGPositionTypeAbsolute) {
+        if (child->getStyle().positionType() == YGPositionTypeAbsolute) {
           // If the child is absolutely positioned and has a
           // top/left/bottom/right set, override all the previously computed
           // positions to set it correctly.
@@ -3053,14 +3113,13 @@ static void YGNodelayoutImpl(
                     child, crossAxis, availableInnerCrossDim)) {
               float childMainSize =
                   child->getLayout().measuredDimensions[dim[mainAxis]];
-              float childCrossSize =
-                  !child->getStyle().aspectRatio.isUndefined()
+              const auto& childStyle = child->getStyle();
+              float childCrossSize = !childStyle.aspectRatio().isUndefined()
                   ? child->getMarginForAxis(crossAxis, availableInnerWidth)
                           .unwrap() +
-                      (isMainAxisRow ? childMainSize /
-                               child->getStyle().aspectRatio.unwrap()
-                                     : childMainSize *
-                               child->getStyle().aspectRatio.unwrap())
+                      (isMainAxisRow
+                           ? childMainSize / childStyle.aspectRatio().unwrap()
+                           : childMainSize * childStyle.aspectRatio().unwrap())
                   : collectedFlexItemsValues.crossDim;
 
               childMainSize +=
@@ -3089,7 +3148,7 @@ static void YGNodelayoutImpl(
               const float childHeight =
                   !isMainAxisRow ? childMainSize : childCrossSize;
 
-              auto alignContent = node->getStyle().alignContent;
+              auto alignContent = node->getStyle().alignContent();
               auto crossAxisDoesNotGrow =
                   alignContent != YGAlignStretch && isNodeFlexWrap;
               const YGMeasureMode childWidthMeasureMode =
@@ -3113,10 +3172,12 @@ static void YGNodelayoutImpl(
                   availableInnerWidth,
                   availableInnerHeight,
                   true,
-                  "stretch",
+                  LayoutPassReason::kStretch,
                   config,
                   layoutMarkerData,
-                  layoutContext);
+                  layoutContext,
+                  depth,
+                  generationCount);
             }
           } else {
             const float remainingCrossDim = containerCrossAxis -
@@ -3161,7 +3222,7 @@ static void YGNodelayoutImpl(
     if (!YGFloatIsUndefined(availableInnerCrossDim)) {
       const float remainingAlignContentDim =
           availableInnerCrossDim - totalLineCrossDim;
-      switch (node->getStyle().alignContent) {
+      switch (node->getStyle().alignContent()) {
         case YGAlignFlexEnd:
           currentLead += remainingAlignContentDim;
           break;
@@ -3205,10 +3266,10 @@ static void YGNodelayoutImpl(
       float maxDescentForCurrentLine = 0;
       for (ii = startIndex; ii < childCount; ii++) {
         const YGNodeRef child = node->getChild(ii);
-        if (child->getStyle().display == YGDisplayNone) {
+        if (child->getStyle().display() == YGDisplayNone) {
           continue;
         }
-        if (child->getStyle().positionType == YGPositionTypeRelative) {
+        if (child->getStyle().positionType() != YGPositionTypeAbsolute) {
           if (child->getLineIndex() != i) {
             break;
           }
@@ -3247,10 +3308,10 @@ static void YGNodelayoutImpl(
       if (performLayout) {
         for (ii = startIndex; ii < endIndex; ii++) {
           const YGNodeRef child = node->getChild(ii);
-          if (child->getStyle().display == YGDisplayNone) {
+          if (child->getStyle().display() == YGDisplayNone) {
             continue;
           }
-          if (child->getStyle().positionType == YGPositionTypeRelative) {
+          if (child->getStyle().positionType() != YGPositionTypeAbsolute) {
             switch (YGNodeAlignItem(node, child)) {
               case YGAlignFlexStart: {
                 child->setLayoutPosition(
@@ -3321,10 +3382,12 @@ static void YGNodelayoutImpl(
                         availableInnerWidth,
                         availableInnerHeight,
                         true,
-                        "multiline-stretch",
+                        LayoutPassReason::kMultilineStretch,
                         config,
                         layoutMarkerData,
-                        layoutContext);
+                        layoutContext,
+                        depth,
+                        generationCount);
                   }
                 }
                 break;
@@ -3376,7 +3439,7 @@ static void YGNodelayoutImpl(
   // If the user didn't specify a width or height for the node, set the
   // dimensions based on the children.
   if (measureModeMainDim == YGMeasureModeUndefined ||
-      (node->getStyle().overflow != YGOverflowScroll &&
+      (node->getStyle().overflow() != YGOverflowScroll &&
        measureModeMainDim == YGMeasureModeAtMost)) {
     // Clamp the size to the min/max size, if specified, and make sure it
     // doesn't go below the padding and border amount.
@@ -3387,7 +3450,7 @@ static void YGNodelayoutImpl(
 
   } else if (
       measureModeMainDim == YGMeasureModeAtMost &&
-      node->getStyle().overflow == YGOverflowScroll) {
+      node->getStyle().overflow() == YGOverflowScroll) {
     node->setLayoutMeasuredDimension(
         YGFloatMax(
             YGFloatMin(
@@ -3403,7 +3466,7 @@ static void YGNodelayoutImpl(
   }
 
   if (measureModeCrossDim == YGMeasureModeUndefined ||
-      (node->getStyle().overflow != YGOverflowScroll &&
+      (node->getStyle().overflow() != YGOverflowScroll &&
        measureModeCrossDim == YGMeasureModeAtMost)) {
     // Clamp the size to the min/max size, if specified, and make sure it
     // doesn't go below the padding and border amount.
@@ -3418,7 +3481,7 @@ static void YGNodelayoutImpl(
 
   } else if (
       measureModeCrossDim == YGMeasureModeAtMost &&
-      node->getStyle().overflow == YGOverflowScroll) {
+      node->getStyle().overflow() == YGOverflowScroll) {
     node->setLayoutMeasuredDimension(
         YGFloatMax(
             YGFloatMin(
@@ -3426,8 +3489,8 @@ static void YGNodelayoutImpl(
                 YGNodeBoundAxisWithinMinAndMax(
                     node,
                     crossAxis,
-                    YGFloatOptional{totalLineCrossDim +
-                                    paddingAndBorderAxisCross},
+                    YGFloatOptional{
+                        totalLineCrossDim + paddingAndBorderAxisCross},
                     crossAxisownerSize)
                     .unwrap()),
             paddingAndBorderAxisCross),
@@ -3436,10 +3499,10 @@ static void YGNodelayoutImpl(
 
   // As we only wrapped in normal direction yet, we need to reverse the
   // positions on wrap-reverse.
-  if (performLayout && node->getStyle().flexWrap == YGWrapWrapReverse) {
+  if (performLayout && node->getStyle().flexWrap() == YGWrapWrapReverse) {
     for (uint32_t i = 0; i < childCount; i++) {
       const YGNodeRef child = YGNodeGetChild(node, i);
-      if (child->getStyle().positionType == YGPositionTypeRelative) {
+      if (child->getStyle().positionType() != YGPositionTypeAbsolute) {
         child->setLayoutPosition(
             node->getLayout().measuredDimensions[dim[crossAxis]] -
                 child->getLayout().position[pos[crossAxis]] -
@@ -3452,7 +3515,8 @@ static void YGNodelayoutImpl(
   if (performLayout) {
     // STEP 10: SIZING AND POSITIONING ABSOLUTE CHILDREN
     for (auto child : node->getChildren()) {
-      if (child->getStyle().positionType != YGPositionTypeAbsolute) {
+      if (child->getStyle().display() == YGDisplayNone ||
+          child->getStyle().positionType() != YGPositionTypeAbsolute) {
         continue;
       }
       YGNodeAbsoluteLayoutChild(
@@ -3464,7 +3528,9 @@ static void YGNodelayoutImpl(
           direction,
           config,
           layoutMarkerData,
-          layoutContext);
+          layoutContext,
+          depth,
+          generationCount);
     }
 
     // STEP 11: SETTING TRAILING POSITIONS FOR CHILDREN
@@ -3477,7 +3543,7 @@ static void YGNodelayoutImpl(
     if (needsMainTrailingPos || needsCrossTrailingPos) {
       for (uint32_t i = 0; i < childCount; i++) {
         const YGNodeRef child = node->getChild(i);
-        if (child->getStyle().display == YGDisplayNone) {
+        if (child->getStyle().display() == YGDisplayNone) {
           continue;
         }
         if (needsMainTrailingPos) {
@@ -3492,7 +3558,6 @@ static void YGNodelayoutImpl(
   }
 }
 
-uint32_t gDepth = 0;
 bool gPrintChanges = false;
 bool gPrintSkips = false;
 
@@ -3554,15 +3619,15 @@ static inline bool YGMeasureModeNewMeasureSizeIsStricterAndStillValid(
       (lastComputedSize <= size || YGFloatsEqual(size, lastComputedSize));
 }
 
-float YGRoundValueToPixelGrid(
-    const float value,
-    const float pointScaleFactor,
+YOGA_EXPORT float YGRoundValueToPixelGrid(
+    const double value,
+    const double pointScaleFactor,
     const bool forceCeil,
     const bool forceFloor) {
-  float scaledValue = value * pointScaleFactor;
+  double scaledValue = value * pointScaleFactor;
   // We want to calculate `fractial` such that `floor(scaledValue) = scaledValue
   // - fractial`.
-  float fractial = fmodf(scaledValue, 1.0f);
+  double fractial = fmod(scaledValue, 1.0);
   if (fractial < 0) {
     // This branch is for handling negative numbers for `value`.
     //
@@ -3581,31 +3646,31 @@ float YGRoundValueToPixelGrid(
     //   - Finding the `floor`: -2.2 - fractial2 = -2.2 - 0.8 = -3
     ++fractial;
   }
-  if (YGFloatsEqual(fractial, 0)) {
+  if (YGDoubleEqual(fractial, 0)) {
     // First we check if the value is already rounded
     scaledValue = scaledValue - fractial;
-  } else if (YGFloatsEqual(fractial, 1.0f)) {
-    scaledValue = scaledValue - fractial + 1.0f;
+  } else if (YGDoubleEqual(fractial, 1.0)) {
+    scaledValue = scaledValue - fractial + 1.0;
   } else if (forceCeil) {
     // Next we check if we need to use forced rounding
-    scaledValue = scaledValue - fractial + 1.0f;
+    scaledValue = scaledValue - fractial + 1.0;
   } else if (forceFloor) {
     scaledValue = scaledValue - fractial;
   } else {
     // Finally we just round the value
     scaledValue = scaledValue - fractial +
-        (!YGFloatIsUndefined(fractial) &&
-                 (fractial > 0.5f || YGFloatsEqual(fractial, 0.5f))
-             ? 1.0f
-             : 0.0f);
+        (!YGDoubleIsUndefined(fractial) &&
+                 (fractial > 0.5 || YGDoubleEqual(fractial, 0.5))
+             ? 1.0
+             : 0.0);
   }
-  return (YGFloatIsUndefined(scaledValue) ||
-          YGFloatIsUndefined(pointScaleFactor))
+  return (YGDoubleIsUndefined(scaledValue) ||
+          YGDoubleIsUndefined(pointScaleFactor))
       ? YGUndefined
-      : scaledValue / pointScaleFactor;
+      : (float) (scaledValue / pointScaleFactor);
 }
 
-bool YGNodeCanUseCachedMeasurement(
+YOGA_EXPORT bool YGNodeCanUseCachedMeasurement(
     const YGMeasureMode widthMode,
     const float width,
     const YGMeasureMode heightMode,
@@ -3695,23 +3760,27 @@ bool YGLayoutNodeInternal(
     const float ownerWidth,
     const float ownerHeight,
     const bool performLayout,
-    const char* reason,
+    const LayoutPassReason reason,
     const YGConfigRef config,
-    YGMarkerLayoutData& layoutMarkerData,
-    void* const layoutContext) {
+    LayoutData& layoutMarkerData,
+    void* const layoutContext,
+    uint32_t depth,
+    const uint32_t generationCount) {
   YGLayout* layout = &node->getLayout();
 
-  gDepth++;
+  depth++;
 
   const bool needToVisitNode =
-      (node->isDirty() && layout->generationCount != gCurrentGenerationCount) ||
+      (node->isDirty() && layout->generationCount != generationCount) ||
       layout->lastOwnerDirection != ownerDirection;
 
   if (needToVisitNode) {
     // Invalidate the cached results.
     layout->nextCachedMeasurementsIndex = 0;
-    layout->cachedLayout.widthMeasureMode = (YGMeasureMode) -1;
-    layout->cachedLayout.heightMeasureMode = (YGMeasureMode) -1;
+    layout->cachedLayout.availableWidth = -1;
+    layout->cachedLayout.availableHeight = -1;
+    layout->cachedLayout.widthMeasureMode = YGMeasureModeUndefined;
+    layout->cachedLayout.heightMeasureMode = YGMeasureModeUndefined;
     layout->cachedLayout.computedWidth = -1;
     layout->cachedLayout.computedHeight = -1;
   }
@@ -3806,8 +3875,8 @@ bool YGLayoutNodeInternal(
           YGLogLevelVerbose,
           nullptr,
           "%s%d.{[skipped] ",
-          YGSpacer(gDepth),
-          gDepth);
+          YGSpacer(depth),
+          depth);
       node->print(layoutContext);
       Log::log(
           node,
@@ -3820,7 +3889,7 @@ bool YGLayoutNodeInternal(
           availableHeight,
           cachedResults->computedWidth,
           cachedResults->computedHeight,
-          reason);
+          LayoutPassReasonToString(reason));
     }
   } else {
     if (gPrintChanges) {
@@ -3829,8 +3898,8 @@ bool YGLayoutNodeInternal(
           YGLogLevelVerbose,
           nullptr,
           "%s%d.{%s",
-          YGSpacer(gDepth),
-          gDepth,
+          YGSpacer(depth),
+          depth,
           needToVisitNode ? "*" : "");
       node->print(layoutContext);
       Log::log(
@@ -3842,7 +3911,7 @@ bool YGLayoutNodeInternal(
           YGMeasureModeName(heightMeasureMode, performLayout),
           availableWidth,
           availableHeight,
-          reason);
+          LayoutPassReasonToString(reason));
     }
 
     YGNodelayoutImpl(
@@ -3857,7 +3926,10 @@ bool YGLayoutNodeInternal(
         performLayout,
         config,
         layoutMarkerData,
-        layoutContext);
+        layoutContext,
+        depth,
+        generationCount,
+        reason);
 
     if (gPrintChanges) {
       Log::log(
@@ -3865,8 +3937,8 @@ bool YGLayoutNodeInternal(
           YGLogLevelVerbose,
           nullptr,
           "%s%d.}%s",
-          YGSpacer(gDepth),
-          gDepth,
+          YGSpacer(depth),
+          depth,
           needToVisitNode ? "*" : "");
       node->print(layoutContext);
       Log::log(
@@ -3878,7 +3950,7 @@ bool YGLayoutNodeInternal(
           YGMeasureModeName(heightMeasureMode, performLayout),
           layout->measuredDimensions[YGDimensionWidth],
           layout->measuredDimensions[YGDimensionHeight],
-          reason);
+          LayoutPassReasonToString(reason));
     }
 
     layout->lastOwnerDirection = ownerDirection;
@@ -3889,7 +3961,7 @@ bool YGLayoutNodeInternal(
         layoutMarkerData.maxMeasureCache =
             layout->nextCachedMeasurementsIndex + 1;
       }
-      if (layout->nextCachedMeasurementsIndex == usedMeasureCacheEntries) {
+      if (layout->nextCachedMeasurementsIndex == YG_MAX_CACHED_RESULT_COUNT) {
         if (gPrintChanges) {
           Log::log(node, YGLogLevelVerbose, nullptr, "Out of cache entries!\n");
         }
@@ -3930,12 +4002,23 @@ bool YGLayoutNodeInternal(
     node->setDirty(false);
   }
 
-  gDepth--;
-  layout->generationCount = gCurrentGenerationCount;
+  layout->generationCount = generationCount;
+
+  LayoutType layoutType;
+  if (performLayout) {
+    layoutType = !needToVisitNode && cachedResults == &layout->cachedLayout
+        ? LayoutType::kCachedLayout
+        : LayoutType::kLayout;
+  } else {
+    layoutType = cachedResults != nullptr ? LayoutType::kCachedMeasure
+                                          : LayoutType::kMeasure;
+  }
+  Event::publish<Event::NodeLayout>(node, {layoutType, layoutContext});
+
   return (needToVisitNode || cachedResults == nullptr);
 }
 
-void YGConfigSetPointScaleFactor(
+YOGA_EXPORT void YGConfigSetPointScaleFactor(
     const YGConfigRef config,
     const float pixelsInPoint) {
   YGAssertWithConfig(
@@ -3954,24 +4037,24 @@ void YGConfigSetPointScaleFactor(
 
 static void YGRoundToPixelGrid(
     const YGNodeRef node,
-    const float pointScaleFactor,
-    const float absoluteLeft,
-    const float absoluteTop) {
+    const double pointScaleFactor,
+    const double absoluteLeft,
+    const double absoluteTop) {
   if (pointScaleFactor == 0.0f) {
     return;
   }
 
-  const float nodeLeft = node->getLayout().position[YGEdgeLeft];
-  const float nodeTop = node->getLayout().position[YGEdgeTop];
+  const double nodeLeft = node->getLayout().position[YGEdgeLeft];
+  const double nodeTop = node->getLayout().position[YGEdgeTop];
 
-  const float nodeWidth = node->getLayout().dimensions[YGDimensionWidth];
-  const float nodeHeight = node->getLayout().dimensions[YGDimensionHeight];
+  const double nodeWidth = node->getLayout().dimensions[YGDimensionWidth];
+  const double nodeHeight = node->getLayout().dimensions[YGDimensionHeight];
 
-  const float absoluteNodeLeft = absoluteLeft + nodeLeft;
-  const float absoluteNodeTop = absoluteTop + nodeTop;
+  const double absoluteNodeLeft = absoluteLeft + nodeLeft;
+  const double absoluteNodeTop = absoluteTop + nodeTop;
 
-  const float absoluteNodeRight = absoluteNodeLeft + nodeWidth;
-  const float absoluteNodeBottom = absoluteNodeTop + nodeHeight;
+  const double absoluteNodeRight = absoluteNodeLeft + nodeWidth;
+  const double absoluteNodeBottom = absoluteNodeTop + nodeHeight;
 
   // If a node has a custom measure function we never want to round down its
   // size as this could lead to unwanted text truncation.
@@ -3989,11 +4072,11 @@ static void YGRoundToPixelGrid(
   // whole number, we don't have any fraction To verify if the result is close
   // to whole number we want to check both floor and ceil numbers
   const bool hasFractionalWidth =
-      !YGFloatsEqual(fmodf(nodeWidth * pointScaleFactor, 1.0), 0) &&
-      !YGFloatsEqual(fmodf(nodeWidth * pointScaleFactor, 1.0), 1.0);
+      !YGDoubleEqual(fmod(nodeWidth * pointScaleFactor, 1.0), 0) &&
+      !YGDoubleEqual(fmod(nodeWidth * pointScaleFactor, 1.0), 1.0);
   const bool hasFractionalHeight =
-      !YGFloatsEqual(fmodf(nodeHeight * pointScaleFactor, 1.0), 0) &&
-      !YGFloatsEqual(fmodf(nodeHeight * pointScaleFactor, 1.0), 1.0);
+      !YGDoubleEqual(fmod(nodeHeight * pointScaleFactor, 1.0), 0) &&
+      !YGDoubleEqual(fmod(nodeHeight * pointScaleFactor, 1.0), 1.0);
 
   node->setLayoutDimension(
       YGRoundValueToPixelGrid(
@@ -4025,21 +4108,31 @@ static void YGRoundToPixelGrid(
   }
 }
 
-void YGNodeCalculateLayoutWithContext(
+static void unsetUseLegacyFlagRecursively(YGNodeRef node) {
+  node->getConfig()->useLegacyStretchBehaviour = false;
+  for (auto child : node->getChildren()) {
+    unsetUseLegacyFlagRecursively(child);
+  }
+}
+
+YOGA_EXPORT void YGNodeCalculateLayoutWithContext(
     const YGNodeRef node,
     const float ownerWidth,
     const float ownerHeight,
     const YGDirection ownerDirection,
     void* layoutContext) {
-  marker::MarkerSection<YGMarkerLayout> marker{node};
+
+  Event::publish<Event::LayoutPassStart>(node, {layoutContext});
+  LayoutData markerData = {};
 
   // Increment the generation count. This will force the recursive routine to
   // visit all dirty nodes at least once. Subsequent visits will be skipped if
   // the input parameters don't change.
-  gCurrentGenerationCount++;
+  gCurrentGenerationCount.fetch_add(1, std::memory_order_relaxed);
   node->resolveDimension();
   float width = YGUndefined;
   YGMeasureMode widthMeasureMode = YGMeasureModeUndefined;
+  const auto& maxDimensions = node->getStyle().maxDimensions();
   if (YGNodeIsStyleDimDefined(node, YGFlexDirectionRow, ownerWidth)) {
     width =
         (YGResolveValue(
@@ -4047,12 +4140,10 @@ void YGNodeCalculateLayoutWithContext(
          node->getMarginForAxis(YGFlexDirectionRow, ownerWidth))
             .unwrap();
     widthMeasureMode = YGMeasureModeExactly;
-  } else if (!YGResolveValue(
-                  node->getStyle().maxDimensions[YGDimensionWidth], ownerWidth)
+  } else if (!YGResolveValue(maxDimensions[YGDimensionWidth], ownerWidth)
                   .isUndefined()) {
-    width = YGResolveValue(
-                node->getStyle().maxDimensions[YGDimensionWidth], ownerWidth)
-                .unwrap();
+    width =
+        YGResolveValue(maxDimensions[YGDimensionWidth], ownerWidth).unwrap();
     widthMeasureMode = YGMeasureModeAtMost;
   } else {
     width = ownerWidth;
@@ -4069,13 +4160,10 @@ void YGNodeCalculateLayoutWithContext(
               node->getMarginForAxis(YGFlexDirectionColumn, ownerWidth))
                  .unwrap();
     heightMeasureMode = YGMeasureModeExactly;
-  } else if (!YGResolveValue(
-                  node->getStyle().maxDimensions[YGDimensionHeight],
-                  ownerHeight)
+  } else if (!YGResolveValue(maxDimensions[YGDimensionHeight], ownerHeight)
                   .isUndefined()) {
-    height = YGResolveValue(
-                 node->getStyle().maxDimensions[YGDimensionHeight], ownerHeight)
-                 .unwrap();
+    height =
+        YGResolveValue(maxDimensions[YGDimensionHeight], ownerHeight).unwrap();
     heightMeasureMode = YGMeasureModeAtMost;
   } else {
     height = ownerHeight;
@@ -4092,25 +4180,27 @@ void YGNodeCalculateLayoutWithContext(
           ownerWidth,
           ownerHeight,
           true,
-          "initial",
+          LayoutPassReason::kInitial,
           node->getConfig(),
-          marker.data,
-          layoutContext)) {
+          markerData,
+          layoutContext,
+          0, // tree root
+          gCurrentGenerationCount.load(std::memory_order_relaxed))) {
     node->setPosition(
-        node->getLayout().direction, ownerWidth, ownerHeight, ownerWidth);
+        node->getLayout().direction(), ownerWidth, ownerHeight, ownerWidth);
     YGRoundToPixelGrid(node, node->getConfig()->pointScaleFactor, 0.0f, 0.0f);
 
 #ifdef DEBUG
     if (node->getConfig()->printTree) {
       YGNodePrint(
           node,
-          (YGPrintOptions)(
-              YGPrintOptionsLayout | YGPrintOptionsChildren |
-              YGPrintOptionsStyle));
+          (YGPrintOptions) (YGPrintOptionsLayout | YGPrintOptionsChildren | YGPrintOptionsStyle));
     }
 #endif
   }
 
+  Event::publish<Event::LayoutPassEnd>(node, {layoutContext, &markerData});
+
   // We want to get rid off `useLegacyStretchBehaviour` from YGConfig. But we
   // aren't sure whether client's of yoga have gotten rid off this flag or not.
   // So logging this in YGLayout would help to find out the call sites depending
@@ -4120,16 +4210,16 @@ void YGNodeCalculateLayoutWithContext(
   // run experiments.
   if (node->getConfig()->shouldDiffLayoutWithoutLegacyStretchBehaviour &&
       node->didUseLegacyFlag()) {
-    const YGNodeRef originalNode = YGNodeDeepClone(node);
-    originalNode->resolveDimension();
+    const YGNodeRef nodeWithoutLegacyFlag = YGNodeDeepClone(node);
+    nodeWithoutLegacyFlag->resolveDimension();
     // Recursively mark nodes as dirty
-    originalNode->markDirtyAndPropogateDownwards();
-    gCurrentGenerationCount++;
+    nodeWithoutLegacyFlag->markDirtyAndPropogateDownwards();
+    gCurrentGenerationCount.fetch_add(1, std::memory_order_relaxed);
     // Rerun the layout, and calculate the diff
-    originalNode->setAndPropogateUseLegacyFlag(false);
-    YGMarkerLayoutData layoutMarkerData;
+    unsetUseLegacyFlagRecursively(nodeWithoutLegacyFlag);
+    LayoutData layoutMarkerData = {};
     if (YGLayoutNodeInternal(
-            originalNode,
+            nodeWithoutLegacyFlag,
             width,
             height,
             ownerDirection,
@@ -4138,42 +4228,42 @@ void YGNodeCalculateLayoutWithContext(
             ownerWidth,
             ownerHeight,
             true,
-            "initial",
-            originalNode->getConfig(),
+            LayoutPassReason::kInitial,
+            nodeWithoutLegacyFlag->getConfig(),
             layoutMarkerData,
-            layoutContext)) {
-      originalNode->setPosition(
-          originalNode->getLayout().direction,
+            layoutContext,
+            0, // tree root
+            gCurrentGenerationCount.load(std::memory_order_relaxed))) {
+      nodeWithoutLegacyFlag->setPosition(
+          nodeWithoutLegacyFlag->getLayout().direction(),
           ownerWidth,
           ownerHeight,
           ownerWidth);
       YGRoundToPixelGrid(
-          originalNode,
-          originalNode->getConfig()->pointScaleFactor,
+          nodeWithoutLegacyFlag,
+          nodeWithoutLegacyFlag->getConfig()->pointScaleFactor,
           0.0f,
           0.0f);
 
       // Set whether the two layouts are different or not.
       auto neededLegacyStretchBehaviour =
-          !originalNode->isLayoutTreeEqualToNode(*node);
+          !nodeWithoutLegacyFlag->isLayoutTreeEqualToNode(*node);
       node->setLayoutDoesLegacyFlagAffectsLayout(neededLegacyStretchBehaviour);
 
 #ifdef DEBUG
-      if (originalNode->getConfig()->printTree) {
+      if (nodeWithoutLegacyFlag->getConfig()->printTree) {
         YGNodePrint(
-            originalNode,
-            (YGPrintOptions)(
-                YGPrintOptionsLayout | YGPrintOptionsChildren |
-                YGPrintOptionsStyle));
+            nodeWithoutLegacyFlag,
+            (YGPrintOptions) (YGPrintOptionsLayout | YGPrintOptionsChildren | YGPrintOptionsStyle));
       }
 #endif
     }
-    YGConfigFreeRecursive(originalNode);
-    YGNodeFreeRecursive(originalNode);
+    YGConfigFreeRecursive(nodeWithoutLegacyFlag);
+    YGNodeFreeRecursive(nodeWithoutLegacyFlag);
   }
 }
 
-void YGNodeCalculateLayout(
+YOGA_EXPORT void YGNodeCalculateLayout(
     const YGNodeRef node,
     const float ownerWidth,
     const float ownerHeight,
@@ -4182,7 +4272,7 @@ void YGNodeCalculateLayout(
       node, ownerWidth, ownerHeight, ownerDirection, nullptr);
 }
 
-void YGConfigSetLogger(const YGConfigRef config, YGLogger logger) {
+YOGA_EXPORT void YGConfigSetLogger(const YGConfigRef config, YGLogger logger) {
   if (logger != nullptr) {
     config->setLogger(logger);
   } else {
@@ -4194,7 +4284,7 @@ void YGConfigSetLogger(const YGConfigRef config, YGLogger logger) {
   }
 }
 
-void YGConfigSetShouldDiffLayoutWithoutLegacyStretchBehaviour(
+YOGA_EXPORT void YGConfigSetShouldDiffLayoutWithoutLegacyStretchBehaviour(
     const YGConfigRef config,
     const bool shouldDiffLayout) {
   config->shouldDiffLayoutWithoutLegacyStretchBehaviour = shouldDiffLayout;
@@ -4203,6 +4293,7 @@ void YGConfigSetShouldDiffLayoutWithoutLegacyStretchBehaviour(
 void YGAssert(const bool condition, const char* message) {
   if (!condition) {
     Log::log(YGNodeRef{nullptr}, YGLogLevelFatal, nullptr, "%s\n", message);
+    throwLogicalErrorWithMessage(message);
   }
 }
 
@@ -4212,6 +4303,7 @@ void YGAssertWithNode(
     const char* message) {
   if (!condition) {
     Log::log(node, YGLogLevelFatal, nullptr, "%s\n", message);
+    throwLogicalErrorWithMessage(message);
   }
 }
 
@@ -4221,10 +4313,11 @@ void YGAssertWithConfig(
     const char* message) {
   if (!condition) {
     Log::log(config, YGLogLevelFatal, nullptr, "%s\n", message);
+    throwLogicalErrorWithMessage(message);
   }
 }
 
-void YGConfigSetExperimentalFeatureEnabled(
+YOGA_EXPORT void YGConfigSetExperimentalFeatureEnabled(
     const YGConfigRef config,
     const YGExperimentalFeature feature,
     const bool enabled) {
@@ -4237,11 +4330,13 @@ bool YGConfigIsExperimentalFeatureEnabled(
   return config->experimentalFeatures[feature];
 }
 
-void YGConfigSetUseWebDefaults(const YGConfigRef config, const bool enabled) {
+YOGA_EXPORT void YGConfigSetUseWebDefaults(
+    const YGConfigRef config,
+    const bool enabled) {
   config->useWebDefaults = enabled;
 }
 
-void YGConfigSetUseLegacyStretchBehaviour(
+YOGA_EXPORT void YGConfigSetUseLegacyStretchBehaviour(
     const YGConfigRef config,
     const bool useLegacyStretchBehaviour) {
   config->useLegacyStretchBehaviour = useLegacyStretchBehaviour;
@@ -4251,15 +4346,15 @@ bool YGConfigGetUseWebDefaults(const YGConfigRef config) {
   return config->useWebDefaults;
 }
 
-void YGConfigSetContext(const YGConfigRef config, void* context) {
+YOGA_EXPORT void YGConfigSetContext(const YGConfigRef config, void* context) {
   config->context = context;
 }
 
-void* YGConfigGetContext(const YGConfigRef config) {
+YOGA_EXPORT void* YGConfigGetContext(const YGConfigRef config) {
   return config->context;
 }
 
-void YGConfigSetCloneNodeFunc(
+YOGA_EXPORT void YGConfigSetCloneNodeFunc(
     const YGConfigRef config,
     const YGCloneNodeFunc callback) {
   config->setCloneNodeCallback(callback);
diff --git a/modules/lwjgl/yoga/src/main/c/Yoga.h b/modules/lwjgl/yoga/src/main/c/Yoga.h
index 753a2f9f8..86cd65e2f 100644
--- a/modules/lwjgl/yoga/src/main/c/Yoga.h
+++ b/modules/lwjgl/yoga/src/main/c/Yoga.h
@@ -1,9 +1,10 @@
-/**
+/*
  * Copyright (c) Facebook, Inc. and its affiliates.
  *
- * This source code is licensed under the MIT license found in the LICENSE
- * file in the root directory of this source tree.
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
  */
+
 #pragma once
 
 #include <assert.h>
@@ -31,6 +32,7 @@ typedef struct YGSize {
 typedef struct YGConfig* YGConfigRef;
 
 typedef struct YGNode* YGNodeRef;
+typedef const struct YGNode* YGNodeConstRef;
 
 typedef YGSize (*YGMeasureFunc)(
     YGNodeRef node,
@@ -38,14 +40,13 @@ typedef YGSize (*YGMeasureFunc)(
     YGMeasureMode widthMode,
     float height,
     YGMeasureMode heightMode);
-typedef float (
-    *YGBaselineFunc)(YGNodeRef node, const float width, const float height);
+typedef float (*YGBaselineFunc)(YGNodeRef node, float width, float height);
 typedef void (*YGDirtiedFunc)(YGNodeRef node);
 typedef void (*YGPrintFunc)(YGNodeRef node);
 typedef void (*YGNodeCleanupFunc)(YGNodeRef node);
 typedef int (*YGLogger)(
-    const YGConfigRef config,
-    const YGNodeRef node,
+    YGConfigRef config,
+    YGNodeRef node,
     YGLogLevel level,
     const char* format,
     va_list args);
@@ -54,31 +55,35 @@ typedef YGNodeRef (
 
 // YGNode
 WIN_EXPORT YGNodeRef YGNodeNew(void);
-WIN_EXPORT YGNodeRef YGNodeNewWithConfig(const YGConfigRef config);
-WIN_EXPORT YGNodeRef YGNodeClone(const YGNodeRef node);
-WIN_EXPORT void YGNodeFree(const YGNodeRef node);
+WIN_EXPORT YGNodeRef YGNodeNewWithConfig(YGConfigRef config);
+WIN_EXPORT YGNodeRef YGNodeClone(YGNodeRef node);
+WIN_EXPORT void YGNodeFree(YGNodeRef node);
 WIN_EXPORT void YGNodeFreeRecursiveWithCleanupFunc(
-    const YGNodeRef node,
+    YGNodeRef node,
     YGNodeCleanupFunc cleanup);
-WIN_EXPORT void YGNodeFreeRecursive(const YGNodeRef node);
-WIN_EXPORT void YGNodeReset(const YGNodeRef node);
-WIN_EXPORT int32_t YGNodeGetInstanceCount(void);
+WIN_EXPORT void YGNodeFreeRecursive(YGNodeRef node);
+WIN_EXPORT void YGNodeReset(YGNodeRef node);
 
 WIN_EXPORT void YGNodeInsertChild(
-    const YGNodeRef node,
-    const YGNodeRef child,
-    const uint32_t index);
-
-WIN_EXPORT void YGNodeRemoveChild(const YGNodeRef node, const YGNodeRef child);
-WIN_EXPORT void YGNodeRemoveAllChildren(const YGNodeRef node);
-WIN_EXPORT YGNodeRef YGNodeGetChild(const YGNodeRef node, const uint32_t index);
-WIN_EXPORT YGNodeRef YGNodeGetOwner(const YGNodeRef node);
-WIN_EXPORT YGNodeRef YGNodeGetParent(const YGNodeRef node);
-WIN_EXPORT uint32_t YGNodeGetChildCount(const YGNodeRef node);
+    YGNodeRef node,
+    YGNodeRef child,
+    uint32_t index);
+
+WIN_EXPORT void YGNodeSwapChild(
+    YGNodeRef node,
+    YGNodeRef child,
+    uint32_t index);
+
+WIN_EXPORT void YGNodeRemoveChild(YGNodeRef node, YGNodeRef child);
+WIN_EXPORT void YGNodeRemoveAllChildren(YGNodeRef node);
+WIN_EXPORT YGNodeRef YGNodeGetChild(YGNodeRef node, uint32_t index);
+WIN_EXPORT YGNodeRef YGNodeGetOwner(YGNodeRef node);
+WIN_EXPORT YGNodeRef YGNodeGetParent(YGNodeRef node);
+WIN_EXPORT uint32_t YGNodeGetChildCount(YGNodeRef node);
 WIN_EXPORT void YGNodeSetChildren(
-    YGNodeRef const owner,
+    YGNodeRef owner,
     const YGNodeRef children[],
-    const uint32_t count);
+    uint32_t count);
 
 WIN_EXPORT void YGNodeSetIsReferenceBaseline(
     YGNodeRef node,
@@ -87,10 +92,10 @@ WIN_EXPORT void YGNodeSetIsReferenceBaseline(
 WIN_EXPORT bool YGNodeIsReferenceBaseline(YGNodeRef node);
 
 WIN_EXPORT void YGNodeCalculateLayout(
-    const YGNodeRef node,
-    const float availableWidth,
-    const float availableHeight,
-    const YGDirection ownerDirection);
+    YGNodeRef node,
+    float availableWidth,
+    float availableHeight,
+    YGDirection ownerDirection);
 
 // Mark a node as dirty. Only valid for nodes with a custom measure function
 // set.
@@ -98,36 +103,34 @@ WIN_EXPORT void YGNodeCalculateLayout(
 // Yoga knows when to mark all other nodes as dirty but because nodes with
 // measure functions depend on information not known to Yoga they must perform
 // this dirty marking manually.
-WIN_EXPORT void YGNodeMarkDirty(const YGNodeRef node);
+WIN_EXPORT void YGNodeMarkDirty(YGNodeRef node);
 
 // Marks the current node and all its descendants as dirty.
 //
-// Intended to be used for Uoga benchmarks. Don't use in production, as calling
+// Intended to be used for Yoga benchmarks. Don't use in production, as calling
 // `YGCalculateLayout` will cause the recalculation of each and every node.
-WIN_EXPORT void YGNodeMarkDirtyAndPropogateToDescendants(const YGNodeRef node);
+WIN_EXPORT void YGNodeMarkDirtyAndPropogateToDescendants(YGNodeRef node);
 
-WIN_EXPORT void YGNodePrint(const YGNodeRef node, const YGPrintOptions options);
+WIN_EXPORT void YGNodePrint(YGNodeRef node, YGPrintOptions options);
 
-WIN_EXPORT bool YGFloatIsUndefined(const float value);
+WIN_EXPORT bool YGFloatIsUndefined(float value);
 
 WIN_EXPORT bool YGNodeCanUseCachedMeasurement(
-    const YGMeasureMode widthMode,
-    const float width,
-    const YGMeasureMode heightMode,
-    const float height,
-    const YGMeasureMode lastWidthMode,
-    const float lastWidth,
-    const YGMeasureMode lastHeightMode,
-    const float lastHeight,
-    const float lastComputedWidth,
-    const float lastComputedHeight,
-    const float marginRow,
-    const float marginColumn,
-    const YGConfigRef config);
-
-WIN_EXPORT void YGNodeCopyStyle(
-    const YGNodeRef dstNode,
-    const YGNodeRef srcNode);
+    YGMeasureMode widthMode,
+    float width,
+    YGMeasureMode heightMode,
+    float height,
+    YGMeasureMode lastWidthMode,
+    float lastWidth,
+    YGMeasureMode lastHeightMode,
+    float lastHeight,
+    float lastComputedWidth,
+    float lastComputedHeight,
+    float marginRow,
+    float marginColumn,
+    YGConfigRef config);
+
+WIN_EXPORT void YGNodeCopyStyle(YGNodeRef dstNode, YGNodeRef srcNode);
 
 WIN_EXPORT void* YGNodeGetContext(YGNodeRef node);
 WIN_EXPORT void YGNodeSetContext(YGNodeRef node, void* context);
@@ -144,167 +147,116 @@ WIN_EXPORT void YGNodeSetHasNewLayout(YGNodeRef node, bool hasNewLayout);
 YGNodeType YGNodeGetNodeType(YGNodeRef node);
 void YGNodeSetNodeType(YGNodeRef node, YGNodeType nodeType);
 WIN_EXPORT bool YGNodeIsDirty(YGNodeRef node);
-bool YGNodeLayoutGetDidUseLegacyFlag(const YGNodeRef node);
+bool YGNodeLayoutGetDidUseLegacyFlag(YGNodeRef node);
 
-WIN_EXPORT void YGNodeStyleSetDirection(
-    const YGNodeRef node,
-    const YGDirection direction);
-WIN_EXPORT YGDirection YGNodeStyleGetDirection(const YGNodeRef node);
+WIN_EXPORT void YGNodeStyleSetDirection(YGNodeRef node, YGDirection direction);
+WIN_EXPORT YGDirection YGNodeStyleGetDirection(YGNodeConstRef node);
 
 WIN_EXPORT void YGNodeStyleSetFlexDirection(
-    const YGNodeRef node,
-    const YGFlexDirection flexDirection);
-WIN_EXPORT YGFlexDirection YGNodeStyleGetFlexDirection(const YGNodeRef node);
+    YGNodeRef node,
+    YGFlexDirection flexDirection);
+WIN_EXPORT YGFlexDirection YGNodeStyleGetFlexDirection(YGNodeConstRef node);
 
 WIN_EXPORT void YGNodeStyleSetJustifyContent(
-    const YGNodeRef node,
-    const YGJustify justifyContent);
-WIN_EXPORT YGJustify YGNodeStyleGetJustifyContent(const YGNodeRef node);
+    YGNodeRef node,
+    YGJustify justifyContent);
+WIN_EXPORT YGJustify YGNodeStyleGetJustifyContent(YGNodeConstRef node);
 
 WIN_EXPORT void YGNodeStyleSetAlignContent(
-    const YGNodeRef node,
-    const YGAlign alignContent);
-WIN_EXPORT YGAlign YGNodeStyleGetAlignContent(const YGNodeRef node);
+    YGNodeRef node,
+    YGAlign alignContent);
+WIN_EXPORT YGAlign YGNodeStyleGetAlignContent(YGNodeConstRef node);
 
-WIN_EXPORT void YGNodeStyleSetAlignItems(
-    const YGNodeRef node,
-    const YGAlign alignItems);
-WIN_EXPORT YGAlign YGNodeStyleGetAlignItems(const YGNodeRef node);
+WIN_EXPORT void YGNodeStyleSetAlignItems(YGNodeRef node, YGAlign alignItems);
+WIN_EXPORT YGAlign YGNodeStyleGetAlignItems(YGNodeConstRef node);
 
-WIN_EXPORT void YGNodeStyleSetAlignSelf(
-    const YGNodeRef node,
-    const YGAlign alignSelf);
-WIN_EXPORT YGAlign YGNodeStyleGetAlignSelf(const YGNodeRef node);
+WIN_EXPORT void YGNodeStyleSetAlignSelf(YGNodeRef node, YGAlign alignSelf);
+WIN_EXPORT YGAlign YGNodeStyleGetAlignSelf(YGNodeConstRef node);
 
 WIN_EXPORT void YGNodeStyleSetPositionType(
-    const YGNodeRef node,
-    const YGPositionType positionType);
-WIN_EXPORT YGPositionType YGNodeStyleGetPositionType(const YGNodeRef node);
-
-WIN_EXPORT void YGNodeStyleSetFlexWrap(
-    const YGNodeRef node,
-    const YGWrap flexWrap);
-WIN_EXPORT YGWrap YGNodeStyleGetFlexWrap(const YGNodeRef node);
-
-WIN_EXPORT void YGNodeStyleSetOverflow(
-    const YGNodeRef node,
-    const YGOverflow overflow);
-WIN_EXPORT YGOverflow YGNodeStyleGetOverflow(const YGNodeRef node);
-
-WIN_EXPORT void YGNodeStyleSetDisplay(
-    const YGNodeRef node,
-    const YGDisplay display);
-WIN_EXPORT YGDisplay YGNodeStyleGetDisplay(const YGNodeRef node);
-
-WIN_EXPORT void YGNodeStyleSetFlex(const YGNodeRef node, const float flex);
-WIN_EXPORT float YGNodeStyleGetFlex(const YGNodeRef node);
-
-WIN_EXPORT void YGNodeStyleSetFlexGrow(
-    const YGNodeRef node,
-    const float flexGrow);
-WIN_EXPORT float YGNodeStyleGetFlexGrow(const YGNodeRef node);
-
-WIN_EXPORT void YGNodeStyleSetFlexShrink(
-    const YGNodeRef node,
-    const float flexShrink);
-WIN_EXPORT float YGNodeStyleGetFlexShrink(const YGNodeRef node);
-
-WIN_EXPORT void YGNodeStyleSetFlexBasis(
-    const YGNodeRef node,
-    const float flexBasis);
-WIN_EXPORT void YGNodeStyleSetFlexBasisPercent(
-    const YGNodeRef node,
-    const float flexBasis);
-WIN_EXPORT void YGNodeStyleSetFlexBasisAuto(const YGNodeRef node);
-WIN_EXPORT YGValue YGNodeStyleGetFlexBasis(const YGNodeRef node);
+    YGNodeRef node,
+    YGPositionType positionType);
+WIN_EXPORT YGPositionType YGNodeStyleGetPositionType(YGNodeConstRef node);
+
+WIN_EXPORT void YGNodeStyleSetFlexWrap(YGNodeRef node, YGWrap flexWrap);
+WIN_EXPORT YGWrap YGNodeStyleGetFlexWrap(YGNodeConstRef node);
+
+WIN_EXPORT void YGNodeStyleSetOverflow(YGNodeRef node, YGOverflow overflow);
+WIN_EXPORT YGOverflow YGNodeStyleGetOverflow(YGNodeConstRef node);
+
+WIN_EXPORT void YGNodeStyleSetDisplay(YGNodeRef node, YGDisplay display);
+WIN_EXPORT YGDisplay YGNodeStyleGetDisplay(YGNodeConstRef node);
+
+WIN_EXPORT void YGNodeStyleSetFlex(YGNodeRef node, float flex);
+WIN_EXPORT float YGNodeStyleGetFlex(YGNodeConstRef node);
+
+WIN_EXPORT void YGNodeStyleSetFlexGrow(YGNodeRef node, float flexGrow);
+WIN_EXPORT float YGNodeStyleGetFlexGrow(YGNodeConstRef node);
+
+WIN_EXPORT void YGNodeStyleSetFlexShrink(YGNodeRef node, float flexShrink);
+WIN_EXPORT float YGNodeStyleGetFlexShrink(YGNodeConstRef node);
+
+WIN_EXPORT void YGNodeStyleSetFlexBasis(YGNodeRef node, float flexBasis);
+WIN_EXPORT void YGNodeStyleSetFlexBasisPercent(YGNodeRef node, float flexBasis);
+WIN_EXPORT void YGNodeStyleSetFlexBasisAuto(YGNodeRef node);
+WIN_EXPORT YGValue YGNodeStyleGetFlexBasis(YGNodeConstRef node);
 
 WIN_EXPORT void YGNodeStyleSetPosition(
-    const YGNodeRef node,
-    const YGEdge edge,
-    const float position);
+    YGNodeRef node,
+    YGEdge edge,
+    float position);
 WIN_EXPORT void YGNodeStyleSetPositionPercent(
-    const YGNodeRef node,
-    const YGEdge edge,
-    const float position);
-WIN_EXPORT YGValue
-YGNodeStyleGetPosition(const YGNodeRef node, const YGEdge edge);
-
-WIN_EXPORT void YGNodeStyleSetMargin(
-    const YGNodeRef node,
-    const YGEdge edge,
-    const float margin);
+    YGNodeRef node,
+    YGEdge edge,
+    float position);
+WIN_EXPORT YGValue YGNodeStyleGetPosition(YGNodeConstRef node, YGEdge edge);
+
+WIN_EXPORT void YGNodeStyleSetMargin(YGNodeRef node, YGEdge edge, float margin);
 WIN_EXPORT void YGNodeStyleSetMarginPercent(
-    const YGNodeRef node,
-    const YGEdge edge,
-    const float margin);
-WIN_EXPORT void YGNodeStyleSetMarginAuto(
-    const YGNodeRef node,
-    const YGEdge edge);
-WIN_EXPORT YGValue
-YGNodeStyleGetMargin(const YGNodeRef node, const YGEdge edge);
+    YGNodeRef node,
+    YGEdge edge,
+    float margin);
+WIN_EXPORT void YGNodeStyleSetMarginAuto(YGNodeRef node, YGEdge edge);
+WIN_EXPORT YGValue YGNodeStyleGetMargin(YGNodeConstRef node, YGEdge edge);
 
 WIN_EXPORT void YGNodeStyleSetPadding(
-    const YGNodeRef node,
-    const YGEdge edge,
-    const float padding);
+    YGNodeRef node,
+    YGEdge edge,
+    float padding);
 WIN_EXPORT void YGNodeStyleSetPaddingPercent(
-    const YGNodeRef node,
-    const YGEdge edge,
-    const float padding);
-WIN_EXPORT YGValue
-YGNodeStyleGetPadding(const YGNodeRef node, const YGEdge edge);
-
-WIN_EXPORT void YGNodeStyleSetBorder(
-    const YGNodeRef node,
-    const YGEdge edge,
-    const float border);
-WIN_EXPORT float YGNodeStyleGetBorder(const YGNodeRef node, const YGEdge edge);
-
-WIN_EXPORT void YGNodeStyleSetWidth(const YGNodeRef node, const float width);
-WIN_EXPORT void YGNodeStyleSetWidthPercent(
-    const YGNodeRef node,
-    const float width);
-WIN_EXPORT void YGNodeStyleSetWidthAuto(const YGNodeRef node);
-WIN_EXPORT YGValue YGNodeStyleGetWidth(const YGNodeRef node);
-
-WIN_EXPORT void YGNodeStyleSetHeight(const YGNodeRef node, const float height);
-WIN_EXPORT void YGNodeStyleSetHeightPercent(
-    const YGNodeRef node,
-    const float height);
-WIN_EXPORT void YGNodeStyleSetHeightAuto(const YGNodeRef node);
-WIN_EXPORT YGValue YGNodeStyleGetHeight(const YGNodeRef node);
-
-WIN_EXPORT void YGNodeStyleSetMinWidth(
-    const YGNodeRef node,
-    const float minWidth);
-WIN_EXPORT void YGNodeStyleSetMinWidthPercent(
-    const YGNodeRef node,
-    const float minWidth);
-WIN_EXPORT YGValue YGNodeStyleGetMinWidth(const YGNodeRef node);
-
-WIN_EXPORT void YGNodeStyleSetMinHeight(
-    const YGNodeRef node,
-    const float minHeight);
-WIN_EXPORT void YGNodeStyleSetMinHeightPercent(
-    const YGNodeRef node,
-    const float minHeight);
-WIN_EXPORT YGValue YGNodeStyleGetMinHeight(const YGNodeRef node);
-
-WIN_EXPORT void YGNodeStyleSetMaxWidth(
-    const YGNodeRef node,
-    const float maxWidth);
-WIN_EXPORT void YGNodeStyleSetMaxWidthPercent(
-    const YGNodeRef node,
-    const float maxWidth);
-WIN_EXPORT YGValue YGNodeStyleGetMaxWidth(const YGNodeRef node);
-
-WIN_EXPORT void YGNodeStyleSetMaxHeight(
-    const YGNodeRef node,
-    const float maxHeight);
-WIN_EXPORT void YGNodeStyleSetMaxHeightPercent(
-    const YGNodeRef node,
-    const float maxHeight);
-WIN_EXPORT YGValue YGNodeStyleGetMaxHeight(const YGNodeRef node);
+    YGNodeRef node,
+    YGEdge edge,
+    float padding);
+WIN_EXPORT YGValue YGNodeStyleGetPadding(YGNodeConstRef node, YGEdge edge);
+
+WIN_EXPORT void YGNodeStyleSetBorder(YGNodeRef node, YGEdge edge, float border);
+WIN_EXPORT float YGNodeStyleGetBorder(YGNodeConstRef node, YGEdge edge);
+
+WIN_EXPORT void YGNodeStyleSetWidth(YGNodeRef node, float width);
+WIN_EXPORT void YGNodeStyleSetWidthPercent(YGNodeRef node, float width);
+WIN_EXPORT void YGNodeStyleSetWidthAuto(YGNodeRef node);
+WIN_EXPORT YGValue YGNodeStyleGetWidth(YGNodeConstRef node);
+
+WIN_EXPORT void YGNodeStyleSetHeight(YGNodeRef node, float height);
+WIN_EXPORT void YGNodeStyleSetHeightPercent(YGNodeRef node, float height);
+WIN_EXPORT void YGNodeStyleSetHeightAuto(YGNodeRef node);
+WIN_EXPORT YGValue YGNodeStyleGetHeight(YGNodeConstRef node);
+
+WIN_EXPORT void YGNodeStyleSetMinWidth(YGNodeRef node, float minWidth);
+WIN_EXPORT void YGNodeStyleSetMinWidthPercent(YGNodeRef node, float minWidth);
+WIN_EXPORT YGValue YGNodeStyleGetMinWidth(YGNodeConstRef node);
+
+WIN_EXPORT void YGNodeStyleSetMinHeight(YGNodeRef node, float minHeight);
+WIN_EXPORT void YGNodeStyleSetMinHeightPercent(YGNodeRef node, float minHeight);
+WIN_EXPORT YGValue YGNodeStyleGetMinHeight(YGNodeConstRef node);
+
+WIN_EXPORT void YGNodeStyleSetMaxWidth(YGNodeRef node, float maxWidth);
+WIN_EXPORT void YGNodeStyleSetMaxWidthPercent(YGNodeRef node, float maxWidth);
+WIN_EXPORT YGValue YGNodeStyleGetMaxWidth(YGNodeConstRef node);
+
+WIN_EXPORT void YGNodeStyleSetMaxHeight(YGNodeRef node, float maxHeight);
+WIN_EXPORT void YGNodeStyleSetMaxHeightPercent(YGNodeRef node, float maxHeight);
+WIN_EXPORT YGValue YGNodeStyleGetMaxHeight(YGNodeConstRef node);
 
 // Yoga specific properties, not compatible with flexbox specification Aspect
 // ratio control the size of the undefined dimension of a node. Aspect ratio is
@@ -321,49 +273,45 @@ WIN_EXPORT YGValue YGNodeStyleGetMaxHeight(const YGNodeRef node);
 // - On a node with flex grow/shrink aspect ratio controls the size of the node
 //   in the cross axis if unset
 // - Aspect ratio takes min/max dimensions into account
-WIN_EXPORT void YGNodeStyleSetAspectRatio(
-    const YGNodeRef node,
-    const float aspectRatio);
-WIN_EXPORT float YGNodeStyleGetAspectRatio(const YGNodeRef node);
-
-WIN_EXPORT float YGNodeLayoutGetLeft(const YGNodeRef node);
-WIN_EXPORT float YGNodeLayoutGetTop(const YGNodeRef node);
-WIN_EXPORT float YGNodeLayoutGetRight(const YGNodeRef node);
-WIN_EXPORT float YGNodeLayoutGetBottom(const YGNodeRef node);
-WIN_EXPORT float YGNodeLayoutGetWidth(const YGNodeRef node);
-WIN_EXPORT float YGNodeLayoutGetHeight(const YGNodeRef node);
-WIN_EXPORT YGDirection YGNodeLayoutGetDirection(const YGNodeRef node);
-WIN_EXPORT bool YGNodeLayoutGetHadOverflow(const YGNodeRef node);
-bool YGNodeLayoutGetDidLegacyStretchFlagAffectLayout(const YGNodeRef node);
+WIN_EXPORT void YGNodeStyleSetAspectRatio(YGNodeRef node, float aspectRatio);
+WIN_EXPORT float YGNodeStyleGetAspectRatio(YGNodeConstRef node);
+
+WIN_EXPORT float YGNodeLayoutGetLeft(YGNodeRef node);
+WIN_EXPORT float YGNodeLayoutGetTop(YGNodeRef node);
+WIN_EXPORT float YGNodeLayoutGetRight(YGNodeRef node);
+WIN_EXPORT float YGNodeLayoutGetBottom(YGNodeRef node);
+WIN_EXPORT float YGNodeLayoutGetWidth(YGNodeRef node);
+WIN_EXPORT float YGNodeLayoutGetHeight(YGNodeRef node);
+WIN_EXPORT YGDirection YGNodeLayoutGetDirection(YGNodeRef node);
+WIN_EXPORT bool YGNodeLayoutGetHadOverflow(YGNodeRef node);
+bool YGNodeLayoutGetDidLegacyStretchFlagAffectLayout(YGNodeRef node);
 
 // Get the computed values for these nodes after performing layout. If they were
 // set using point values then the returned value will be the same as
 // YGNodeStyleGetXXX. However if they were set using a percentage value then the
 // returned value is the computed value used during layout.
-WIN_EXPORT float YGNodeLayoutGetMargin(const YGNodeRef node, const YGEdge edge);
-WIN_EXPORT float YGNodeLayoutGetBorder(const YGNodeRef node, const YGEdge edge);
-WIN_EXPORT float YGNodeLayoutGetPadding(
-    const YGNodeRef node,
-    const YGEdge edge);
-
-WIN_EXPORT void YGConfigSetLogger(const YGConfigRef config, YGLogger logger);
-WIN_EXPORT void YGAssert(const bool condition, const char* message);
+WIN_EXPORT float YGNodeLayoutGetMargin(YGNodeRef node, YGEdge edge);
+WIN_EXPORT float YGNodeLayoutGetBorder(YGNodeRef node, YGEdge edge);
+WIN_EXPORT float YGNodeLayoutGetPadding(YGNodeRef node, YGEdge edge);
+
+WIN_EXPORT void YGConfigSetLogger(YGConfigRef config, YGLogger logger);
+WIN_EXPORT void YGAssert(bool condition, const char* message);
 WIN_EXPORT void YGAssertWithNode(
-    const YGNodeRef node,
-    const bool condition,
+    YGNodeRef node,
+    bool condition,
     const char* message);
 WIN_EXPORT void YGAssertWithConfig(
-    const YGConfigRef config,
-    const bool condition,
+    YGConfigRef config,
+    bool condition,
     const char* message);
 // Set this to number of pixels in 1 point to round calculation results If you
 // want to avoid rounding - set PointScaleFactor to 0
 WIN_EXPORT void YGConfigSetPointScaleFactor(
-    const YGConfigRef config,
-    const float pixelsInPoint);
+    YGConfigRef config,
+    float pixelsInPoint);
 void YGConfigSetShouldDiffLayoutWithoutLegacyStretchBehaviour(
-    const YGConfigRef config,
-    const bool shouldDiffLayout);
+    YGConfigRef config,
+    bool shouldDiffLayout);
 
 // Yoga previously had an error where containers would take the maximum space
 // possible instead of the minimum like they are supposed to. In practice this
@@ -371,45 +319,43 @@ void YGConfigSetShouldDiffLayoutWithoutLegacyStretchBehaviour(
 // was such a long-standing bug we must allow legacy users to switch back to
 // this behaviour.
 WIN_EXPORT void YGConfigSetUseLegacyStretchBehaviour(
-    const YGConfigRef config,
-    const bool useLegacyStretchBehaviour);
+    YGConfigRef config,
+    bool useLegacyStretchBehaviour);
 
 // YGConfig
 WIN_EXPORT YGConfigRef YGConfigNew(void);
-WIN_EXPORT void YGConfigFree(const YGConfigRef config);
-WIN_EXPORT void YGConfigCopy(const YGConfigRef dest, const YGConfigRef src);
+WIN_EXPORT void YGConfigFree(YGConfigRef config);
+WIN_EXPORT void YGConfigCopy(YGConfigRef dest, YGConfigRef src);
 WIN_EXPORT int32_t YGConfigGetInstanceCount(void);
 
 WIN_EXPORT void YGConfigSetExperimentalFeatureEnabled(
-    const YGConfigRef config,
-    const YGExperimentalFeature feature,
-    const bool enabled);
+    YGConfigRef config,
+    YGExperimentalFeature feature,
+    bool enabled);
 WIN_EXPORT bool YGConfigIsExperimentalFeatureEnabled(
-    const YGConfigRef config,
-    const YGExperimentalFeature feature);
+    YGConfigRef config,
+    YGExperimentalFeature feature);
 
-// Using the web defaults is the prefered configuration for new projects. Usage
+// Using the web defaults is the preferred configuration for new projects. Usage
 // of non web defaults should be considered as legacy.
-WIN_EXPORT void YGConfigSetUseWebDefaults(
-    const YGConfigRef config,
-    const bool enabled);
-WIN_EXPORT bool YGConfigGetUseWebDefaults(const YGConfigRef config);
+WIN_EXPORT void YGConfigSetUseWebDefaults(YGConfigRef config, bool enabled);
+WIN_EXPORT bool YGConfigGetUseWebDefaults(YGConfigRef config);
 
 WIN_EXPORT void YGConfigSetCloneNodeFunc(
-    const YGConfigRef config,
-    const YGCloneNodeFunc callback);
+    YGConfigRef config,
+    YGCloneNodeFunc callback);
 
 // Export only for C#
 WIN_EXPORT YGConfigRef YGConfigGetDefault(void);
 
-WIN_EXPORT void YGConfigSetContext(const YGConfigRef config, void* context);
-WIN_EXPORT void* YGConfigGetContext(const YGConfigRef config);
+WIN_EXPORT void YGConfigSetContext(YGConfigRef config, void* context);
+WIN_EXPORT void* YGConfigGetContext(YGConfigRef config);
 
 WIN_EXPORT float YGRoundValueToPixelGrid(
-    const float value,
-    const float pointScaleFactor,
-    const bool forceCeil,
-    const bool forceFloor);
+    double value,
+    double pointScaleFactor,
+    bool forceCeil,
+    bool forceFloor);
 
 YG_EXTERN_C_END
 
@@ -419,12 +365,10 @@ YG_EXTERN_C_END
 #include <vector>
 
 // Calls f on each node in the tree including the given node argument.
-extern void YGTraversePreOrder(
-    YGNodeRef const node,
+void YGTraversePreOrder(
+    YGNodeRef node,
     std::function<void(YGNodeRef node)>&& f);
 
-extern void YGNodeSetChildren(
-    YGNodeRef const owner,
-    const std::vector<YGNodeRef>& children);
+void YGNodeSetChildren(YGNodeRef owner, const std::vector<YGNodeRef>& children);
 
 #endif
diff --git a/modules/lwjgl/yoga/src/main/c/event/event.cpp b/modules/lwjgl/yoga/src/main/c/event/event.cpp
new file mode 100644
index 000000000..3af3e83a0
--- /dev/null
+++ b/modules/lwjgl/yoga/src/main/c/event/event.cpp
@@ -0,0 +1,86 @@
+/*
+ * Copyright (c) Facebook, Inc. and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+#include "event.h"
+#include <atomic>
+#include <memory>
+
+namespace facebook {
+namespace yoga {
+
+const char* LayoutPassReasonToString(const LayoutPassReason value) {
+  switch (value) {
+    case LayoutPassReason::kInitial:
+      return "initial";
+    case LayoutPassReason::kAbsLayout:
+      return "abs_layout";
+    case LayoutPassReason::kStretch:
+      return "stretch";
+    case LayoutPassReason::kMultilineStretch:
+      return "multiline_stretch";
+    case LayoutPassReason::kFlexLayout:
+      return "flex_layout";
+    case LayoutPassReason::kMeasureChild:
+      return "measure";
+    case LayoutPassReason::kAbsMeasureChild:
+      return "abs_measure";
+    case LayoutPassReason::kFlexMeasure:
+      return "flex_measure";
+    default:
+      return "unknown";
+  }
+}
+
+namespace {
+
+struct Node {
+  std::function<Event::Subscriber> subscriber = nullptr;
+  Node* next = nullptr;
+
+  Node(std::function<Event::Subscriber>&& subscriber)
+      : subscriber{std::move(subscriber)} {}
+};
+
+std::atomic<Node*> subscribers{nullptr};
+
+Node* push(Node* newHead) {
+  Node* oldHead;
+  do {
+    oldHead = subscribers.load(std::memory_order_relaxed);
+    if (newHead != nullptr) {
+      newHead->next = oldHead;
+    }
+  } while (!subscribers.compare_exchange_weak(
+      oldHead, newHead, std::memory_order_release, std::memory_order_relaxed));
+  return oldHead;
+}
+
+} // namespace
+
+void Event::reset() {
+  auto head = push(nullptr);
+  while (head != nullptr) {
+    auto current = head;
+    head = head->next;
+    delete current;
+  }
+}
+
+void Event::subscribe(std::function<Subscriber>&& subscriber) {
+  push(new Node{std::move(subscriber)});
+}
+
+void Event::publish(const YGNode& node, Type eventType, const Data& eventData) {
+  for (auto subscriber = subscribers.load(std::memory_order_relaxed);
+       subscriber != nullptr;
+       subscriber = subscriber->next) {
+    subscriber->subscriber(node, eventType, eventData);
+  }
+}
+
+} // namespace yoga
+} // namespace facebook
diff --git a/modules/lwjgl/yoga/src/main/c/event/event.h b/modules/lwjgl/yoga/src/main/c/event/event.h
new file mode 100644
index 000000000..8ce2c131f
--- /dev/null
+++ b/modules/lwjgl/yoga/src/main/c/event/event.h
@@ -0,0 +1,146 @@
+/*
+ * Copyright (c) Facebook, Inc. and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+#pragma once
+
+#include <functional>
+#include <vector>
+#include <array>
+#include "YGEnums.h"
+#include <stdint.h>
+
+struct YGConfig;
+struct YGNode;
+
+namespace facebook {
+namespace yoga {
+
+enum struct LayoutType : int {
+  kLayout = 0,
+  kMeasure = 1,
+  kCachedLayout = 2,
+  kCachedMeasure = 3
+};
+
+enum struct LayoutPassReason : int {
+  kInitial = 0,
+  kAbsLayout = 1,
+  kStretch = 2,
+  kMultilineStretch = 3,
+  kFlexLayout = 4,
+  kMeasureChild = 5,
+  kAbsMeasureChild = 6,
+  kFlexMeasure = 7,
+  COUNT
+};
+
+struct LayoutData {
+  int layouts;
+  int measures;
+  int maxMeasureCache;
+  int cachedLayouts;
+  int cachedMeasures;
+  int measureCallbacks;
+  std::array<int, static_cast<uint8_t>(LayoutPassReason::COUNT)>
+      measureCallbackReasonsCount;
+};
+
+const char* LayoutPassReasonToString(const LayoutPassReason value);
+
+struct YOGA_EXPORT Event {
+  enum Type {
+    NodeAllocation,
+    NodeDeallocation,
+    NodeLayout,
+    LayoutPassStart,
+    LayoutPassEnd,
+    MeasureCallbackStart,
+    MeasureCallbackEnd,
+    NodeBaselineStart,
+    NodeBaselineEnd,
+  };
+  class Data;
+  using Subscriber = void(const YGNode&, Type, Data);
+  using Subscribers = std::vector<std::function<Subscriber>>;
+
+  template <Type E>
+  struct TypedData {};
+
+  class Data {
+    const void* data_;
+
+  public:
+    template <Type E>
+    Data(const TypedData<E>& data) : data_{&data} {}
+
+    template <Type E>
+    const TypedData<E>& get() const {
+      return *static_cast<const TypedData<E>*>(data_);
+    };
+  };
+
+  static void reset();
+
+  static void subscribe(std::function<Subscriber>&& subscriber);
+
+  template <Type E>
+  static void publish(const YGNode& node, const TypedData<E>& eventData = {}) {
+#ifdef YG_ENABLE_EVENTS
+    publish(node, E, Data{eventData});
+#endif
+  }
+
+  template <Type E>
+  static void publish(const YGNode* node, const TypedData<E>& eventData = {}) {
+    publish<E>(*node, eventData);
+  }
+
+private:
+  static void publish(const YGNode&, Type, const Data&);
+};
+
+template <>
+struct Event::TypedData<Event::NodeAllocation> {
+  YGConfig* config;
+};
+
+template <>
+struct Event::TypedData<Event::NodeDeallocation> {
+  YGConfig* config;
+};
+
+template <>
+struct Event::TypedData<Event::LayoutPassStart> {
+  void* layoutContext;
+};
+
+template <>
+struct Event::TypedData<Event::LayoutPassEnd> {
+  void* layoutContext;
+  LayoutData* layoutData;
+};
+
+template <>
+struct Event::TypedData<Event::MeasureCallbackEnd> {
+  void* layoutContext;
+  float width;
+  YGMeasureMode widthMeasureMode;
+  float height;
+  YGMeasureMode heightMeasureMode;
+  float measuredWidth;
+  float measuredHeight;
+  const LayoutPassReason reason;
+};
+
+template <>
+struct Event::TypedData<Event::NodeLayout> {
+  LayoutType layoutType;
+  void* layoutContext;
+};
+
+} // namespace yoga
+} // namespace facebook
diff --git a/modules/lwjgl/yoga/src/main/c/instrumentation.h b/modules/lwjgl/yoga/src/main/c/instrumentation.h
deleted file mode 100644
index b8691c186..000000000
--- a/modules/lwjgl/yoga/src/main/c/instrumentation.h
+++ /dev/null
@@ -1,63 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the LICENSE
- * file in the root directory of this source tree.
- */
-#include "YGConfig.h"
-#include "YGMarker.h"
-#include "YGNode.h"
-
-namespace facebook {
-namespace yoga {
-namespace marker {
-
-template <YGMarker MarkerType>
-class MarkerSection {
-private:
-  using Data = detail::MarkerData<MarkerType>;
-
-public:
-  MarkerSection(YGNodeRef node) : MarkerSection{node, node->getConfig()} {}
-  ~MarkerSection() {
-    if (endMarker_) {
-      endMarker_(MarkerType, node_, markerData(&data), userData_);
-    }
-  }
-
-  typename Data::type data = {};
-
-  template <typename Ret, typename... Args>
-  static Ret wrap(
-      YGNodeRef node,
-      Ret (YGNode::*method)(Args...),
-      Args... args) {
-    MarkerSection<MarkerType> section{node};
-    return (node->*method)(std::forward<Args>(args)...);
-  }
-
-private:
-  decltype(YGMarkerCallbacks{}.endMarker) endMarker_;
-  YGNodeRef node_;
-  void* userData_;
-
-  MarkerSection(YGNodeRef node, YGConfigRef config)
-      : MarkerSection{node, config ? &config->markerCallbacks : nullptr} {}
-  MarkerSection(YGNodeRef node, YGMarkerCallbacks* callbacks)
-      : endMarker_{callbacks ? callbacks->endMarker : nullptr},
-        node_{node},
-        userData_{
-            callbacks && callbacks->startMarker
-                ? callbacks->startMarker(MarkerType, node, markerData(&data))
-                : nullptr} {}
-
-  static YGMarkerData markerData(typename Data::type* d) {
-    YGMarkerData markerData = {};
-    Data::get(markerData) = d;
-    return markerData;
-  }
-};
-
-} // namespace marker
-} // namespace yoga
-} // namespace facebook
diff --git a/modules/lwjgl/yoga/src/main/c/log.cpp b/modules/lwjgl/yoga/src/main/c/log.cpp
index 62b3d4f05..eb3da039c 100644
--- a/modules/lwjgl/yoga/src/main/c/log.cpp
+++ b/modules/lwjgl/yoga/src/main/c/log.cpp
@@ -1,9 +1,10 @@
-/**
+/*
  * Copyright (c) Facebook, Inc. and its affiliates.
  *
- * This source code is licensed under the MIT license found in the LICENSE
- * file in the root directory of this source tree.
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
  */
+
 #include "log.h"
 
 #include "Yoga.h"
@@ -25,14 +26,10 @@ void vlog(
     va_list args) {
   YGConfig* logConfig = config != nullptr ? config : YGConfigGetDefault();
   logConfig->log(logConfig, node, level, context, format, args);
-
-  if (level == YGLogLevelFatal) {
-    abort();
-  }
 }
 } // namespace
 
-void Log::log(
+YOGA_EXPORT void Log::log(
     YGNode* node,
     YGLogLevel level,
     void* context,
diff --git a/modules/lwjgl/yoga/src/main/c/log.h b/modules/lwjgl/yoga/src/main/c/log.h
index f25ee1a2b..ae33744c5 100644
--- a/modules/lwjgl/yoga/src/main/c/log.h
+++ b/modules/lwjgl/yoga/src/main/c/log.h
@@ -1,9 +1,10 @@
-/**
+/*
  * Copyright (c) Facebook, Inc. and its affiliates.
  *
- * This source code is licensed under the MIT license found in the LICENSE
- * file in the root directory of this source tree.
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
  */
+
 #pragma once
 
 #include "YGEnums.h"
